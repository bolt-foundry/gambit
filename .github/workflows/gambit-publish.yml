name: Gambit Publish (JSR + npm)
on:
  push:
    branches:
      - main

jobs:
  publish:
    runs-on: blacksmith-4vcpu-ubuntu-2404
    permissions:
      contents: write
      id-token: write
    defaults:
      run:
        shell: nix develop --command bash -euo pipefail {0}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v13

      - name: Register Deno problem matcher
        run: echo '::add-matcher::.github/deno-problem-matcher.json'

      - name: Prepare local gambit-core import map
        run: |
          deno eval -q '
            const exists = async (path) => {
              try {
                await Deno.stat(path);
                return true;
              } catch (err) {
                if (err instanceof Deno.errors.NotFound) {
                  return false;
                }
                throw err;
              }
            };
            const findPath = async (candidates, label) => {
              for (const candidate of candidates) {
                if (await exists(candidate)) {
                  return candidate;
                }
              }
              throw new Error(
                `Unable to find ${label} at: ${candidates.join(", ")}`,
              );
            };
            const gambitPath = await findPath(
              ["deno.json", "packages/gambit/deno.json"],
              "gambit deno.json",
            );
            const corePath = await findPath(
              ["packages/gambit-core/deno.json"],
              "gambit-core deno.json",
            );
            const gambit = JSON.parse(await Deno.readTextFile(gambitPath));
            const core = JSON.parse(await Deno.readTextFile(corePath));
            const exportsMap = core.exports ?? {};
            const localImports = {};
            for (const [key, value] of Object.entries(exportsMap)) {
              if (typeof value !== "string") continue;
              const suffix = key === "." ? "" : key.startsWith("./")
                ? key.slice(1)
                : key;
              const spec = `@bolt-foundry/gambit-core${suffix}`;
              const rel = value.startsWith("./") ? value.slice(2) : value;
              localImports[spec] = `./packages/gambit-core/${rel}`;
            }
            gambit.imports = { ...(gambit.imports ?? {}), ...localImports };
            await Deno.writeTextFile(
              "deno.ci.json",
              JSON.stringify(gambit, null, 2) + "\n",
            );
          '

      - name: Read package metadata
        id: meta
        run: |
          deno eval -q '
            const gambitPath = "deno.json";
            const corePath = "packages/gambit-core/deno.json";
            const gambit = JSON.parse(await Deno.readTextFile(gambitPath));
            const core = JSON.parse(await Deno.readTextFile(corePath));
            const gambitVersion = (gambit.version ?? "").trim();
            const coreVersion = (core.version ?? "").trim();
            if (!gambitVersion) throw new Error("deno.json missing version");
            if (!coreVersion) throw new Error("packages/gambit-core/deno.json missing version");
            if (gambitVersion !== coreVersion) {
              throw new Error(`gambit ${gambitVersion} != gambit-core ${coreVersion}`);
            }
            const gambitName = (gambit.name ?? "").trim();
            const coreName = (core.name ?? "").trim();
            if (!gambitName) throw new Error("deno.json missing name");
            if (!coreName) throw new Error("packages/gambit-core/deno.json missing name");
            const imports = gambit.imports ?? {};
            const prefix = "jsr:@bolt-foundry/gambit-core@";
            for (const value of Object.values(imports)) {
              if (typeof value !== "string") continue;
              if (!value.startsWith(prefix)) continue;
              const remainder = value.slice(prefix.length);
              const version = remainder.split("/")[0];
              if (version !== gambitVersion) {
                throw new Error(
                  `gambit import map references gambit-core@${version} (expected ${gambitVersion})`,
                );
              }
            }
            console.log(`version=${gambitVersion}`);
            console.log(`gambit_package=${gambitName}`);
            console.log(`core_package=${coreName}`);
          ' >> "$GITHUB_OUTPUT"

      - name: Detect release version
        id: release
        run: |
          version="${{ steps.meta.outputs.version }}"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "is_release=true" >> "$GITHUB_OUTPUT"
            if git rev-parse "v${version}" >/dev/null 2>&1; then
              echo "tag_exists=true" >> "$GITHUB_OUTPUT"
            else
              echo "tag_exists=false" >> "$GITHUB_OUTPUT"
            fi
            check_jsr() {
              local label="$1"
              local package="$2"
              local version="$3"
              local meta_url="https://jsr.io/${package}/meta.json"
              if deno eval -q '
                const [url, version] = Deno.args;
                const res = await fetch(url);
                if (!res.ok) {
                  console.error(`Failed to fetch ${url}: ${res.status}`);
                  Deno.exit(2);
                }
                const data = await res.json();
                const versions = data?.versions ?? {};
                if (Object.prototype.hasOwnProperty.call(versions, version)) {
                  Deno.exit(0);
                }
                Deno.exit(1);
              ' "$meta_url" "$version"; then
                echo "${label}_jsr_published=true" >> "$GITHUB_OUTPUT"
              else
                status=$?
                if [ "$status" -ne 1 ]; then
                  echo "::warning::Could not verify JSR metadata for ${package} (exit $status); assuming not published"
                fi
                echo "${label}_jsr_published=false" >> "$GITHUB_OUTPUT"
              fi
            }
            check_jsr gambit "${{ steps.meta.outputs.gambit_package }}" "$version"
            check_jsr core "${{ steps.meta.outputs.core_package }}" "$version"
          else
            echo "is_release=false" >> "$GITHUB_OUTPUT"
            echo "tag_exists=false" >> "$GITHUB_OUTPUT"
            echo "gambit_jsr_published=false" >> "$GITHUB_OUTPUT"
            echo "core_jsr_published=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Lint (gambit)
        run: deno lint --config deno.ci.json

      - name: Guard bfmono imports
        run: deno run -A --config deno.ci.json scripts/guard-bfmono-imports.ts

      - name: Format check (gambit)
        run: deno fmt --config deno.ci.json --check

      - name: Type check (gambit)
        run: deno check --config deno.ci.json --all mod.ts

      - name: Test (gambit)
        run: deno test --config deno.ci.json -A --ignore=simulator-ui/__tests__/e2e

      - name: Lint (gambit-core)
        run: deno lint
        working-directory: packages/gambit-core

      - name: Format check (gambit-core)
        run: deno fmt --check
        working-directory: packages/gambit-core

      - name: Type check (gambit-core)
        run: deno check --all mod.ts
        working-directory: packages/gambit-core

      - name: Test (gambit-core)
        run: deno task test
        working-directory: packages/gambit-core

      - name: Compute canary version
        id: canary
        run: |
          CANARY_TS=$(date -u +%s)
          BASE_VERSION="$(deno eval -q 'const data = JSON.parse(await Deno.readTextFile("deno.json")); const version = (data.version ?? "").trim(); if (!version) throw new Error("deno.json missing version"); console.log(version.replace(/^v/, ""));')"
          if [[ "$BASE_VERSION" == *-* ]]; then
            CANARY_VERSION="${BASE_VERSION}.main.${CANARY_TS}"
          else
            CANARY_VERSION="${BASE_VERSION}-main.${CANARY_TS}"
          fi
          echo "version=${CANARY_VERSION}" >> "$GITHUB_OUTPUT"
          echo "Publishing canary ${CANARY_VERSION}"

      - name: Build simulator bundle
        run: deno task bundle:sim:web:sourcemap

      - name: Allow simulator bundle for publish
        run: |
          cat <<'EOF' >> .gitignore

          # Allow Gambit simulator bundle for JSR publish.
          !simulator-ui/dist/
          !simulator-ui/dist/bundle.js
          !simulator-ui/dist/bundle.js.map
          !packages/gambit/simulator-ui/dist/
          !packages/gambit/simulator-ui/dist/bundle.js
          !packages/gambit/simulator-ui/dist/bundle.js.map
          EOF

      - name: Publish canary
        run: |
          cp deno.json deno.publish-backup.json
          cp packages/gambit-core/deno.json packages/gambit-core/deno.publish-backup.json
          trap 'mv deno.publish-backup.json deno.json; mv packages/gambit-core/deno.publish-backup.json packages/gambit-core/deno.json' EXIT
          deno eval '
            const version = Deno.env.get("CANARY_VERSION");
            if (!version) throw new Error("CANARY_VERSION env var missing");
            const gambitPath = "deno.json";
            const corePath = "packages/gambit-core/deno.json";
            const core = JSON.parse(await Deno.readTextFile(corePath));
            core.version = version;
            await Deno.writeTextFile(corePath, JSON.stringify(core, null, 2) + "\n");
            const gambit = JSON.parse(await Deno.readTextFile(gambitPath));
            gambit.version = version;
            const imports = gambit.imports ?? {};
            const prefix = "jsr:@bolt-foundry/gambit-core@";
            const updated = {};
            for (const [key, value] of Object.entries(imports)) {
              if (typeof value === "string" && value.startsWith(prefix)) {
                const remainder = value.slice(prefix.length);
                const slashIndex = remainder.indexOf("/");
                const suffix = slashIndex === -1 ? "" : remainder.slice(slashIndex);
                updated[key] = `${prefix}${version}${suffix}`;
                continue;
              }
              updated[key] = value;
            }
            gambit.imports = updated;
            await Deno.writeTextFile(gambitPath, JSON.stringify(gambit, null, 2) + "\n");
          '
          (cd packages/gambit-core && deno publish --allow-dirty)
          deno publish --allow-dirty
        env:
          CANARY_VERSION: ${{ steps.canary.outputs.version }}

      - name: Tag release
        if: steps.release.outputs.is_release == 'true' && steps.release.outputs.tag_exists != 'true'
        run: |
          version="${{ steps.release.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "v${version}"
          git push origin "v${version}"

      - name: Publish release (gambit-core)
        if: steps.release.outputs.is_release == 'true' && steps.release.outputs.core_jsr_published != 'true'
        run: deno publish --allow-dirty
        working-directory: packages/gambit-core

      - name: Publish release (gambit)
        if: steps.release.outputs.is_release == 'true' && steps.release.outputs.gambit_jsr_published != 'true'
        run: deno publish --allow-dirty

      - name: Publish release (gambit-core npm)
        if: steps.release.outputs.is_release == 'true'
        run: |
          version="${{ steps.release.outputs.version }}"
          package="${{ steps.meta.outputs.core_package }}"
          if npm view "${package}@${version}" version >/dev/null 2>&1; then
            echo "npm already has ${package}@${version}; skipping"
            exit 0
          fi
          deno task build_npm
          npm publish ./dist/npm --access public
        working-directory: packages/gambit-core
