name: Gambit Publish (JSR + npm)
on:
  push:
    branches:
      - main

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: write
      id-token: write
    defaults:
      run:
        shell: nix develop ${{ github.workspace }} --command bash -euo pipefail {0}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v13

      - name: Register Deno problem matcher
        run: echo '::add-matcher::.github/deno-problem-matcher.json'

      - name: Prepare local gambit-core import map
        run: |
          deno eval --ext=ts -q '
            import { parse } from "jsr:@std/jsonc@1";
            const exists = async (path) => {
              try {
                await Deno.stat(path);
                return true;
              } catch (err) {
                if (err instanceof Deno.errors.NotFound) {
                  return false;
                }
                throw err;
              }
            };
            const findPath = async (candidates, label) => {
              for (const candidate of candidates) {
                if (await exists(candidate)) {
                  return candidate;
                }
              }
              throw new Error(
                `Unable to find ${label} at: ${candidates.join(", ")}`,
              );
            };
            const gambitPath = await findPath(
              [
                "deno.jsonc",
                "deno.json",
                "packages/gambit/deno.jsonc",
                "packages/gambit/deno.json",
              ],
              "gambit deno.json(c)",
            );
            const corePath = await findPath(
              ["packages/gambit-core/deno.json"],
              "gambit-core deno.json",
            );
            const gambit = parse(await Deno.readTextFile(gambitPath));
            const core = parse(await Deno.readTextFile(corePath));
            const exportsMap = core.exports ?? {};
            const localImports = {};
            for (const [key, value] of Object.entries(exportsMap)) {
              if (typeof value !== "string") continue;
              const suffix = key === "." ? "" : key.startsWith("./")
                ? key.slice(1)
                : key;
              const spec = `@bolt-foundry/gambit-core${suffix}`;
              const rel = value.startsWith("./") ? value.slice(2) : value;
              localImports[spec] = `./packages/gambit-core/${rel}`;
            }
            gambit.imports = { ...(gambit.imports ?? {}), ...localImports };
            await Deno.writeTextFile(
              "deno.ci.json",
              JSON.stringify(gambit, null, 2) + "\n",
            );
          '

      - name: Read package metadata
        id: meta
        run: |
          deno eval --ext=ts -q '
            import { parse } from "jsr:@std/jsonc@1";
            const findPath = async (candidates, label) => {
              for (const candidate of candidates) {
                try {
                  await Deno.stat(candidate);
                  return candidate;
                } catch (err) {
                  if (err instanceof Deno.errors.NotFound) {
                    continue;
                  }
                  throw err;
                }
              }
              throw new Error(`Unable to find ${label}`);
            };
            const gambitPath = await findPath(
              ["deno.jsonc", "deno.json"],
              "gambit deno.json(c)",
            );
            const corePath = "packages/gambit-core/deno.json";
            const gambit = parse(await Deno.readTextFile(gambitPath));
            const core = parse(await Deno.readTextFile(corePath));
            const gambitVersion = (gambit.version ?? "").trim();
            const coreVersion = (core.version ?? "").trim();
            if (!gambitVersion) throw new Error(`${gambitPath} missing version`);
            if (!coreVersion) throw new Error("packages/gambit-core/deno.json missing version");
            if (gambitVersion !== coreVersion) {
              throw new Error(`gambit ${gambitVersion} != gambit-core ${coreVersion}`);
            }
            const gambitName = (gambit.name ?? "").trim();
            const coreName = (core.name ?? "").trim();
            if (!gambitName) throw new Error(`${gambitPath} missing name`);
            if (!coreName) throw new Error("packages/gambit-core/deno.json missing name");
            const imports = gambit.imports ?? {};
            const prefix = "jsr:@bolt-foundry/gambit-core@";
            for (const value of Object.values(imports)) {
              if (typeof value !== "string") continue;
              if (!value.startsWith(prefix)) continue;
              const remainder = value.slice(prefix.length);
              const version = remainder.split("/")[0];
              if (version !== gambitVersion) {
                throw new Error(
                  `gambit import map references gambit-core@${version} (expected ${gambitVersion})`,
                );
              }
            }
            console.log(`version=${gambitVersion}`);
            console.log(`gambit_package=${gambitName}`);
            console.log(`core_package=${coreName}`);
          ' >> "$GITHUB_OUTPUT"

      - name: Detect release version
        id: release
        run: |
          version="${{ steps.meta.outputs.version }}"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "is_release=true" >> "$GITHUB_OUTPUT"
            if git rev-parse "v${version}" >/dev/null 2>&1; then
              echo "tag_exists=true" >> "$GITHUB_OUTPUT"
            else
              echo "tag_exists=false" >> "$GITHUB_OUTPUT"
            fi
            check_jsr() {
              local label="$1"
              local package="$2"
              local version="$3"
              local meta_url="https://jsr.io/${package}/meta.json"
              if deno eval -q '
                const [url, version] = Deno.args;
                const res = await fetch(url);
                if (!res.ok) {
                  console.error(`Failed to fetch ${url}: ${res.status}`);
                  Deno.exit(2);
                }
                const data = await res.json();
                const versions = data?.versions ?? {};
                if (Object.prototype.hasOwnProperty.call(versions, version)) {
                  Deno.exit(0);
                }
                Deno.exit(1);
              ' "$meta_url" "$version"; then
                echo "${label}_jsr_published=true" >> "$GITHUB_OUTPUT"
              else
                status=$?
                if [ "$status" -ne 1 ]; then
                  echo "::warning::Could not verify JSR metadata for ${package} (exit $status); assuming not published"
                fi
                echo "${label}_jsr_published=false" >> "$GITHUB_OUTPUT"
              fi
            }
            check_jsr gambit "${{ steps.meta.outputs.gambit_package }}" "$version"
            check_jsr core "${{ steps.meta.outputs.core_package }}" "$version"
          else
            echo "is_release=false" >> "$GITHUB_OUTPUT"
            echo "tag_exists=false" >> "$GITHUB_OUTPUT"
            echo "gambit_jsr_published=false" >> "$GITHUB_OUTPUT"
            echo "core_jsr_published=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Lint (gambit)
        run: deno lint --config deno.ci.json

      - name: Guard bfmono imports
        run: deno run -A --config deno.ci.json scripts/guard-bfmono-imports.ts

      - name: Format check (gambit)
        run: deno fmt --config deno.ci.json --check

      - name: Type check (gambit)
        run: deno check --config deno.ci.json --all mod.ts

      - name: Test (gambit)
        run: deno test --config deno.ci.json -A --ignore=simulator-ui/__tests__/e2e

      - name: Lint (gambit-core)
        run: deno lint
        working-directory: packages/gambit-core

      - name: Format check (gambit-core)
        run: deno fmt --check
        working-directory: packages/gambit-core

      - name: Type check (gambit-core)
        run: deno check --all mod.ts
        working-directory: packages/gambit-core

      - name: Test (gambit-core)
        run: deno task test
        working-directory: packages/gambit-core

      - name: Compute canary version
        id: canary
        run: |
          CANARY_TS=$(date -u +%s)
          GAMBIT_CONFIG="deno.json"
          if [ -f "deno.jsonc" ]; then
            GAMBIT_CONFIG="deno.jsonc"
          fi
          BASE_VERSION="$(GAMBIT_CONFIG="$GAMBIT_CONFIG" deno eval --ext=ts -q 'import { parse } from "jsr:@std/jsonc@1"; const path = Deno.env.get("GAMBIT_CONFIG") ?? "deno.json"; const data = parse(await Deno.readTextFile(path)); const version = (data.version ?? "").trim(); if (!version) throw new Error(`${path} missing version`); console.log(version.replace(/^v/, ""));')"
          if [[ "$BASE_VERSION" == *-* ]]; then
            CANARY_VERSION="${BASE_VERSION}.main.${CANARY_TS}"
          else
            CANARY_VERSION="${BASE_VERSION}-main.${CANARY_TS}"
          fi
          echo "version=${CANARY_VERSION}" >> "$GITHUB_OUTPUT"
          echo "Publishing canary ${CANARY_VERSION}"

      - name: Build simulator bundle
        run: deno task bundle:sim:web:sourcemap

      - name: Install CLI deps (entrypoint only)
        run: |
          rm -f deno.entrypoint.lock
          deno install --entrypoint --config deno.ci.json --lock=deno.entrypoint.lock --frozen=false --no-prompt src/cli.ts

      - name: Allow simulator bundle for publish
        run: |
          cat <<'EOF' >> .gitignore

          # Allow Gambit simulator bundle for JSR publish.
          !simulator-ui/dist/
          !simulator-ui/dist/bundle.js
          !simulator-ui/dist/bundle.js.map
          !packages/gambit/simulator-ui/dist/
          !packages/gambit/simulator-ui/dist/bundle.js
          !packages/gambit/simulator-ui/dist/bundle.js.map
          EOF

      - name: Publish canary
        run: |
          gambit_config="deno.json"
          if [ -f "deno.jsonc" ]; then
            gambit_config="deno.jsonc"
          fi
          export GAMBIT_CONFIG="$gambit_config"
          cp "$gambit_config" "${gambit_config}.publish-backup"
          cp packages/gambit-core/deno.json packages/gambit-core/deno.publish-backup.json
          init_template="packages/gambit/examples/init/deno.json"
          if [ -f "$init_template" ]; then
            cp "$init_template" "${init_template}.publish-backup"
            rm -f "$init_template"
          fi
          trap 'mv "${gambit_config}.publish-backup" "$gambit_config"; mv packages/gambit-core/deno.publish-backup.json packages/gambit-core/deno.json; if [ -f "${init_template}.publish-backup" ]; then mv "${init_template}.publish-backup" "$init_template"; fi' EXIT
          deno eval --ext=ts '
            import { parse } from "jsr:@std/jsonc@1";
            const version = Deno.env.get("CANARY_VERSION");
            if (!version) throw new Error("CANARY_VERSION env var missing");
            const gambitPath = Deno.env.get("GAMBIT_CONFIG") ?? "deno.json";
            const corePath = "packages/gambit-core/deno.json";
            const core = parse(await Deno.readTextFile(corePath));
            core.version = version;
            await Deno.writeTextFile(corePath, JSON.stringify(core, null, 2) + "\n");
            const gambit = parse(await Deno.readTextFile(gambitPath));
            gambit.version = version;
            const imports = gambit.imports ?? {};
            const prefix = "jsr:@bolt-foundry/gambit-core@";
            const coreKey = "@bolt-foundry/gambit-core";
            const updated = {};
            for (const [key, value] of Object.entries(imports)) {
              if (
                typeof value === "string" &&
                (key === coreKey || key.startsWith(`${coreKey}/`))
              ) {
                const suffix = key === coreKey ? "" : key.slice(coreKey.length);
                updated[key] = `${prefix}${version}${suffix}`;
                continue;
              }
              if (typeof value === "string" && value.startsWith(prefix)) {
                const remainder = value.slice(prefix.length);
                const slashIndex = remainder.indexOf("/");
                const suffix = slashIndex === -1 ? "" : remainder.slice(slashIndex);
                updated[key] = `${prefix}${version}${suffix}`;
                continue;
              }
              updated[key] = value;
            }
            gambit.imports = updated;
            await Deno.writeTextFile(gambitPath, JSON.stringify(gambit, null, 2) + "\n");

            const initPath = "packages/gambit/examples/init/package.json";
            const init = JSON.parse(await Deno.readTextFile(initPath));
            init.dependencies ??= {};
            init.dependencies["@bolt-foundry/gambit-core"] =
              `npm:@bolt-foundry/gambit-core@${version}`;
            await Deno.writeTextFile(initPath, JSON.stringify(init, null, 2) + "\n");
          '
          (cd packages/gambit-core && deno publish --allow-dirty)
          deno publish --allow-dirty
        env:
          CANARY_VERSION: ${{ steps.canary.outputs.version }}

      - name: Tag release
        if: steps.release.outputs.is_release == 'true' && steps.release.outputs.tag_exists != 'true'
        run: |
          version="${{ steps.release.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "v${version}"
          git push origin "v${version}"

      - name: Dispatch release-binaries
        if: steps.release.outputs.is_release == 'true'
        run: |
          version="${{ steps.release.outputs.version }}"
          curl -sSf -X POST \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/release-binaries.yml/dispatches" \
            -d "{\"ref\":\"main\",\"inputs\":{\"tag\":\"v${version}\"}}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Wait for release binaries
        if: steps.release.outputs.is_release == 'true'
        run: |
          version="${{ steps.release.outputs.version }}"
          tag="v${version}"
          api="https://api.github.com/repos/${{ github.repository }}/releases/tags/${tag}"
          max_attempts=30
          delay_seconds=20
          required_assets=(
            "gambit-darwin-arm64.gz"
            "gambit-darwin-x64.gz"
            "gambit-linux-arm64.gz"
            "gambit-linux-x64.gz"
            "SHA256SUMS"
          )
          for attempt in $(seq 1 "$max_attempts"); do
            release_json="$(mktemp)"
            status="$(curl -sS -o "$release_json" -w "%{http_code}" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "$api" || true)"
            if [ "$status" = "200" ]; then
              missing="$(RELEASE_JSON="$release_json" REQUIRED_ASSETS="$REQUIRED_ASSETS" deno eval -q --ext=ts '
                const path = Deno.env.get("RELEASE_JSON");
                const required = (Deno.env.get("REQUIRED_ASSETS") ?? "")
                  .split(",")
                  .filter(Boolean);
                if (!path) {
                  throw new Error("RELEASE_JSON env var missing");
                }
                const data = JSON.parse(await Deno.readTextFile(path));
                const assets = (data.assets ?? []).map((asset: { name?: string }) =>
                  asset?.name
                );
                const missing = required.filter((name) => !assets.includes(name));
                console.log(missing.join("\\n"));
              ')"
              if [ -z "$missing" ]; then
                echo "Release assets present for ${tag}."
                rm -f "$release_json"
                break
              fi
              echo "Release assets not ready yet (missing: ${missing//$'\n'/, })."
            else
              echo "Release ${tag} not ready yet (HTTP ${status})."
            fi
            rm -f "$release_json"
            if [ "$attempt" -eq "$max_attempts" ]; then
              echo "Timed out waiting for release binaries for ${tag}."
              exit 1
            fi
            sleep "$delay_seconds"
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REQUIRED_ASSETS: "gambit-darwin-arm64.gz,gambit-darwin-x64.gz,gambit-linux-arm64.gz,gambit-linux-x64.gz,SHA256SUMS"

      - name: Prepare release publish config
        if: steps.release.outputs.is_release == 'true'
        run: |
          gambit_config="deno.json"
          if [ -f "deno.jsonc" ]; then
            gambit_config="deno.jsonc"
          fi
          export GAMBIT_CONFIG="$gambit_config"
          cp "$gambit_config" "${gambit_config}.publish-backup"
          cp packages/gambit-core/deno.json packages/gambit-core/deno.publish-backup.json
          init_template="packages/gambit/examples/init/deno.json"
          if [ -f "$init_template" ]; then
            cp "$init_template" "${init_template}.publish-backup"
            rm -f "$init_template"
          fi
          deno eval --ext=ts '
            import { parse } from "jsr:@std/jsonc@1";
            const version = Deno.env.get("RELEASE_VERSION");
            if (!version) throw new Error("RELEASE_VERSION env var missing");
            const gambitPath = Deno.env.get("GAMBIT_CONFIG") ?? "deno.json";
            const corePath = "packages/gambit-core/deno.json";
            const core = parse(await Deno.readTextFile(corePath));
            core.version = version;
            await Deno.writeTextFile(corePath, JSON.stringify(core, null, 2) + "\n");
            const gambit = parse(await Deno.readTextFile(gambitPath));
            gambit.version = version;
            const imports = gambit.imports ?? {};
            const prefix = "jsr:@bolt-foundry/gambit-core@";
            const coreKey = "@bolt-foundry/gambit-core";
            const updated = {};
            for (const [key, value] of Object.entries(imports)) {
              if (
                typeof value === "string" &&
                (key === coreKey || key.startsWith(`${coreKey}/`))
              ) {
                const suffix = key === coreKey ? "" : key.slice(coreKey.length);
                updated[key] = `${prefix}${version}${suffix}`;
                continue;
              }
              if (typeof value === "string" && value.startsWith(prefix)) {
                const remainder = value.slice(prefix.length);
                const slashIndex = remainder.indexOf("/");
                const suffix = slashIndex === -1 ? "" : remainder.slice(slashIndex);
                updated[key] = `${prefix}${version}${suffix}`;
                continue;
              }
              updated[key] = value;
            }
            gambit.imports = updated;
            await Deno.writeTextFile(gambitPath, JSON.stringify(gambit, null, 2) + "\n");

            const initPath = "packages/gambit/examples/init/package.json";
            const init = JSON.parse(await Deno.readTextFile(initPath));
            init.dependencies ??= {};
            init.dependencies["@bolt-foundry/gambit-core"] =
              `npm:@bolt-foundry/gambit-core@${version}`;
            await Deno.writeTextFile(initPath, JSON.stringify(init, null, 2) + "\n");
          '
        env:
          RELEASE_VERSION: ${{ steps.release.outputs.version }}

      - name: Publish release (gambit-core)
        if: steps.release.outputs.is_release == 'true' && steps.release.outputs.core_jsr_published != 'true'
        run: deno publish --allow-dirty
        working-directory: packages/gambit-core

      - name: Publish release (gambit)
        if: steps.release.outputs.is_release == 'true' && steps.release.outputs.gambit_jsr_published != 'true'
        run: deno publish --allow-dirty

      - name: Publish release (gambit-core npm)
        if: steps.release.outputs.is_release == 'true'
        run: |
          version="${{ steps.release.outputs.version }}"
          package="${{ steps.meta.outputs.core_package }}"
          if npm view "${package}@${version}" version >/dev/null 2>&1; then
            echo "npm already has ${package}@${version}; skipping"
            exit 0
          fi
          deno task build_npm
          npm publish ./dist/npm --access public
        working-directory: packages/gambit-core
        env:
          NPM_CONFIG_PROVENANCE: "true"

      - name: Publish release (gambit npm)
        if: steps.release.outputs.is_release == 'true'
        run: |
          version="${{ steps.release.outputs.version }}"
          package="${{ steps.meta.outputs.gambit_package }}"
          core_package="${{ steps.meta.outputs.core_package }}"
          if npm view "${package}@${version}" version >/dev/null 2>&1; then
            echo "npm already has ${package}@${version}; skipping"
            exit 0
          fi
          max_attempts=6
          delay_seconds=10
          for attempt in $(seq 1 "$max_attempts"); do
            if npm view "${core_package}@${version}" version >/dev/null 2>&1; then
              echo "npm has ${core_package}@${version}"
              break
            fi
            if [ "$attempt" -eq "$max_attempts" ]; then
              echo "Timed out waiting for ${core_package}@${version} to appear on npm"
              exit 1
            fi
            echo "Waiting for ${core_package}@${version} to appear on npm (attempt ${attempt}/${max_attempts})"
            sleep "$delay_seconds"
          done
          deno task build_npm
          npm publish ./dist/npm --access public
        env:
          NPM_CONFIG_PROVENANCE: "true"

      - name: Restore release publish config
        if: steps.release.outputs.is_release == 'true'
        run: |
          gambit_config="deno.json"
          if [ -f "deno.jsonc" ]; then
            gambit_config="deno.jsonc"
          fi
          if [ -f "${gambit_config}.publish-backup" ]; then
            mv "${gambit_config}.publish-backup" "$gambit_config"
          fi
          if [ -f packages/gambit-core/deno.publish-backup.json ]; then
            mv packages/gambit-core/deno.publish-backup.json packages/gambit-core/deno.json
          fi
          init_template="packages/gambit/examples/init/deno.json"
          if [ -f "${init_template}.publish-backup" ]; then
            mv "${init_template}.publish-backup" "$init_template"
          fi
