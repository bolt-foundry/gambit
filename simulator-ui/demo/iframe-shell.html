<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Gambit Demo Harness</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: light dark;
        font-family:
          "Inter", "SF Pro Display", -apple-system, BlinkMacSystemFont,
          "Segoe UI", sans-serif;
        --shell-width: 1920px;
        --shell-height: 1080px;
        --browser-bar-height: 56px;
        --browser-tabs-height: 40px;
        --chrome-height: calc(
          var(--browser-bar-height) + var(--browser-tabs-height)
        );
        --content-height: calc(var(--shell-height) - var(--chrome-height));
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: #020617;
        color: #f1f5f9;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 0;
        box-sizing: border-box;
      }
      .demo-shell {
        position: relative;
        flex: 1;
        min-height: 100vh;
        width: 100%;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        transform-origin: top left;
      }
      .browser-shell {
        position: relative;
        width: var(--shell-width);
        height: var(--shell-height);
        max-width: 100vw;
        max-height: 100vh;
        border-radius: 24px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.9),
          rgba(248, 250, 255, 0.95)
        );
        box-shadow: 0 25px 80px rgba(2, 6, 23, 0.45);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .browser-bar {
        height: var(--browser-bar-height);
        padding: 8px 16px;
        display: flex;
        align-items: center;
        gap: 14px;
        background: linear-gradient(180deg, #e8ecf7, #dbe2f4);
        border-bottom: 1px solid rgba(15, 23, 42, 0.08);
        box-sizing: border-box;
      }
      .browser-activity {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: #60a5fa;
        box-shadow: 0 0 0 rgba(96, 165, 250, 0.6);
        animation: chromePulse 2.4s ease-in-out infinite;
      }
      .browser-dots {
        display: flex;
        gap: 8px;
      }
      .browser-dot {
        width: 12px;
        height: 12px;
        border-radius: 999px;
        background: #f87171;
        box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.6);
      }
      .browser-dot:nth-child(2) {
        background: #facc15;
      }
      .browser-dot:nth-child(3) {
        background: #34d399;
      }
      .browser-address {
        flex: 1;
        height: 32px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.85);
        display: flex;
        align-items: center;
        padding: 0 12px;
        font-size: 13px;
        color: #1e293b;
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.08);
      }
      @keyframes chromePulse {
        0% {
          transform: scale(0.85);
          box-shadow: 0 0 0 0 rgba(96, 165, 250, 0.45);
        }
        50% {
          transform: scale(1);
          box-shadow: 0 0 0 6px rgba(96, 165, 250, 0);
        }
        100% {
          transform: scale(0.85);
          box-shadow: 0 0 0 0 rgba(96, 165, 250, 0);
        }
      }
      .browser-tabs {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 0 18px;
        height: var(--browser-tabs-height);
        border-bottom: 1px solid rgba(15, 23, 42, 0.06);
        background: rgba(241, 244, 251, 0.85);
        box-sizing: border-box;
      }
      .browser-tab {
        padding: 6px 14px;
        border-radius: 12px;
        background: white;
        color: #0f172a;
        font-size: 13px;
        font-weight: 600;
        border: 1px solid rgba(148, 163, 184, 0.4);
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
      }
      .browser-tab.is-active {
        border-color: #3b82f6;
        color: #1d4ed8;
        box-shadow: 0 4px 10px rgba(59, 130, 246, 0.35);
      }
      .browser-content {
        flex: none;
        height: var(--content-height);
        background: #111827;
        position: relative;
        overflow: hidden;
      }
      .frame-stage {
        width: 100%;
        height: 100%;
        transform-origin: top left;
        will-change: transform;
        backface-visibility: hidden;
      }
      .browser-content iframe {
        display: block;
        width: 100%;
        height: 100%;
        border: none;
      }
      .overlay-root {
        pointer-events: none;
        position: absolute;
        inset: 0;
      }
      .overlay-root.overlay-hidden .overlay-panel,
      .overlay-root.overlay-hidden .overlay-badge,
      .overlay-root.overlay-hidden .highlight-box {
        opacity: 0;
        pointer-events: none;
      }
      .overlay-panel {
        pointer-events: none;
        position: absolute;
        top: 24px;
        right: 24px;
        width: min(320px, calc(100% - 32px));
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid rgba(226, 232, 240, 0.3);
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 10px 40px rgba(2, 6, 23, 0.5);
        display: flex;
        flex-direction: column;
        gap: 12px;
        max-height: calc(100% - 48px);
        overflow-y: auto;
        transition: opacity 200ms ease;
      }
      .overlay-panel button {
        pointer-events: none;
        cursor: pointer;
        background: #0ea5e9;
        border: none;
        color: #0f172a;
        font-weight: 600;
        border-radius: 10px;
        padding: 10px 14px;
      }
      .overlay-panel button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .overlay-badge {
        position: absolute;
        top: 16px;
        left: 16px;
        padding: 10px 18px;
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.9);
        color: #0f172a;
        font-weight: 700;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        box-shadow: 0 10px 30px rgba(2, 6, 23, 0.4);
        font-size: 12px;
        transition: opacity 200ms ease;
      }
      .highlight-box {
        position: absolute;
        border: 2px solid #38bdf8;
        border-radius: 16px;
        box-shadow: 0 0 30px rgba(14, 165, 233, 0.6);
        transition: opacity 200ms ease;
      }
      .highlight-box.hidden {
        opacity: 0;
      }
      .demo-cursor {
        position: absolute;
        width: 26px;
        height: 26px;
        left: 0;
        top: 0;
        transform: translate3d(-9999px, -9999px, 0);
        pointer-events: none;
        z-index: 60;
        opacity: 0;
        transition: opacity 120ms ease;
        filter: drop-shadow(0 6px 12px rgba(15, 23, 42, 0.35));
      }
      .demo-cursor.visible {
        opacity: 1;
      }
      .demo-cursor svg {
        width: 100%;
        height: 100%;
        display: block;
      }
      .cursor-ring {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 6px;
        height: 6px;
        border-radius: 999px;
        border: 2px solid rgba(59, 130, 246, 0.8);
        transform: translate(-50%, -50%) scale(0.6);
        opacity: 0;
        pointer-events: none;
      }
      .demo-cursor.clicking .cursor-ring {
        animation: cursorClick 500ms ease-out;
      }
      @keyframes cursorClick {
        0% {
          transform: translate(-50%, -50%) scale(0.6);
          opacity: 0.7;
        }
        100% {
          transform: translate(-50%, -50%) scale(2.4);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="demo-shell">
      <div class="browser-shell">
        <div class="browser-bar">
          <div class="browser-dots">
            <span class="browser-dot"></span>
            <span class="browser-dot"></span>
            <span class="browser-dot"></span>
          </div>
          <div class="browser-activity" aria-hidden="true"></div>
          <div class="browser-address">
            https://demo.gambit.local
          </div>
        </div>
        <div class="browser-tabs">
          <div class="browser-tab is-active">Gambit Simulator</div>
          <div class="browser-tab">Docs</div>
        </div>
        <div class="browser-content">
          <div class="frame-stage">
            <iframe id="demo-frame" title="Gambit Demo"></iframe>
          </div>
        </div>
        <div class="overlay-root overlay-hidden">
          <div class="overlay-badge">Iframe overlay active</div>
          <div id="highlight" class="highlight-box hidden"></div>
          <section class="overlay-panel">
            <div>
              <div
                style="font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; color: #94a3b8"
              >
                Walkthrough prototype
              </div>
              <h1 style="margin: 4px 0 0; font-size: 18px">Iframe Harness</h1>
              <p style="margin: 6px 0 0; font-size: 14px; color: #cbd5f5">
                Drive Gambit UI via same-origin iframe + smooth scrolling.
              </p>
            </div>
            <button
              id="overlay-hide"
              type="button"
              style="align-self: flex-start; background: rgba(148, 163, 184, 0.2); color: #e2e8f0"
            >
              Hide overlay
            </button>
            <div style="display: flex; gap: 8px; flex-wrap: wrap">
              <button data-action="scroll" data-target=".top-nav">
                Scroll to Top Nav
              </button>
              <button
                data-action="scroll"
                data-target="[data-testid=nav-calibrate]"
              >
                Scroll Calibrate
              </button>
              <button
                data-action="highlight"
                data-target='[data-testid="testbot-run"]'
              >
                Highlight Run Button
              </button>
              <button
                data-action="zoom"
                data-target='[data-testid="testbot-run"]'
              >
                Zoom Run Button
              </button>
              <button data-action="zoom-reset">
                Reset Zoom
              </button>
            </div>
          </section>
        </div>
        <div id="demo-cursor" class="demo-cursor" aria-hidden="true">
          <svg viewBox="0 0 24 24" fill="none">
            <path
              d="M4 3.5l14 6.2c.9.4.9 1.7 0 2.1l-5.7 2.7-2.6 5.7c-.4.9-1.7.9-2.1 0L4 3.5z"
              fill="#0f172a"
            />
            <path
              d="M6.4 6.4l9.6 4.2-4.3 2-2 4.3-3.3-10.5z"
              fill="#f8fafc"
            />
          </svg>
          <div class="cursor-ring"></div>
        </div>
      </div>
    </div>
    <script>
      const frame = document.getElementById("demo-frame");
      const highlight = document.getElementById("highlight");
      const overlayRoot = document.querySelector(".overlay-root");
      const demoShell = document.querySelector(".demo-shell");
      const browserShell = document.querySelector(".browser-shell");
      const frameStage = document.querySelector(".frame-stage");
      const hideOverlayButton = document.getElementById("overlay-hide");
      const cursor = document.getElementById("demo-cursor");
      const zoomState = { x: 0, y: 0, scale: 1 };
      const audioState = {
        recorder: null,
        chunks: [],
        streams: [],
        context: null,
        mimeType: "",
      };
      const videoState = {
        recorder: null,
        chunks: [],
        stream: null,
        sourceStreams: [],
        audioContext: null,
        mimeType: "",
        totalBytes: 0,
      };

      hideOverlayButton?.addEventListener("click", () => {
        overlayRoot?.classList.add("overlay-hidden");
      });

      const params = new URLSearchParams(window.location.search);
      const base = params.get("base") || window.location.origin;
      const path = params.get("path") || "/";
      const shellParam = params.get("shell") || params.get("viewport");
      const contentParam = params.get("content");
      const chromeHeight = getChromeHeight();
      const shellSize = parseSize(shellParam);
      const contentSize = parseSize(contentParam);
      if (shellSize) {
        setShellSize(shellSize.width, shellSize.height);
      } else if (contentSize) {
        setShellSize(
          contentSize.width,
          contentSize.height + chromeHeight,
        );
      }
      const displayUrl = new URL(path, base).toString();
      frame.src = displayUrl;
      const addressBar = document.querySelector(".browser-address");
      if (addressBar) {
        addressBar.textContent = displayUrl;
      }
      let activeDoc = null;
      let cursorRaf = 0;
      let pendingCursor = null;

      function updateCursorPosition(pos) {
        pendingCursor = pos;
        if (cursorRaf) return;
        cursorRaf = requestAnimationFrame(() => {
          cursorRaf = 0;
          if (!pendingCursor || !cursor) return;
          cursor.style.transform =
            `translate3d(${pendingCursor.x}px, ${pendingCursor.y}px, 0)`;
          cursor.classList.add("visible");
          pendingCursor = null;
        });
      }

      function triggerCursorClick() {
        if (!cursor) return;
        cursor.classList.remove("clicking");
        void cursor.offsetWidth;
        cursor.classList.add("clicking");
      }

      function hideCursor() {
        if (!cursor) return;
        cursor.classList.remove("visible");
      }

      function wireCursorHandlers(doc) {
        if (!doc) return null;
        const onMove = (event) => {
          if (!browserShell) return;
          const frameRect = frame.getBoundingClientRect();
          const shellRect = browserShell.getBoundingClientRect();
          const x = frameRect.left - shellRect.left + event.clientX - 2;
          const y = frameRect.top - shellRect.top + event.clientY - 2;
          updateCursorPosition({ x, y });
        };
        const onLeave = () => hideCursor();
        const onClick = () => triggerCursorClick();
        doc.addEventListener("mousemove", onMove);
        doc.addEventListener("mouseleave", onLeave);
        doc.addEventListener("click", onClick);
        return () => {
          doc.removeEventListener("mousemove", onMove);
          doc.removeEventListener("mouseleave", onLeave);
          doc.removeEventListener("click", onClick);
        };
      }
      frame.addEventListener("load", () => {
        if (!addressBar) return;
        const frameUrl = frame.contentWindow?.location?.href;
        if (frameUrl) {
          addressBar.textContent = frameUrl;
        }
        if (activeDoc?.cleanup) {
          activeDoc.cleanup();
        }
        const doc = frame.contentDocument;
        if (doc) {
          activeDoc = { cleanup: wireCursorHandlers(doc) };
        }
      });

      const easeInOut = (t) =>
        t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

      function applyZoom() {
        if (!demoShell) return;
        demoShell.style.transform =
          `translate3d(${zoomState.x}px, ${zoomState.y}px, 0) scale(${zoomState.scale})`;
      }

      function animateZoom(target, duration = 700) {
        const start = { ...zoomState };
        if (!demoShell?.animate) {
          zoomState.x = target.x;
          zoomState.y = target.y;
          zoomState.scale = target.scale;
          applyZoom();
          return Promise.resolve();
        }
        const animation = demoShell.animate(
          [
            {
              transform:
                `translate3d(${start.x}px, ${start.y}px, 0) scale(${start.scale})`,
            },
            {
              transform:
                `translate3d(${target.x}px, ${target.y}px, 0) scale(${target.scale})`,
            },
          ],
          {
            duration,
            easing: "cubic-bezier(0.33, 1, 0.68, 1)",
            fill: "forwards",
          },
        );
        return animation.finished
          .catch(() => {})
          .finally(() => {
            zoomState.x = target.x;
            zoomState.y = target.y;
            zoomState.scale = target.scale;
            applyZoom();
            animation.cancel();
          });
      }

      function setShellSize(width, height) {
        document.documentElement.style.setProperty(
          "--shell-width",
          `${width}px`,
        );
        document.documentElement.style.setProperty(
          "--shell-height",
          `${height}px`,
        );
      }

      function getChromeHeight() {
        const styles = getComputedStyle(document.documentElement);
        const bar = parseFloat(
          styles.getPropertyValue("--browser-bar-height"),
        );
        const tabs = parseFloat(
          styles.getPropertyValue("--browser-tabs-height"),
        );
        const total = Number.isFinite(bar) && Number.isFinite(tabs)
          ? bar + tabs
          : 96;
        return total;
      }

      function parseSize(raw) {
        if (!raw) return null;
        const match = raw.trim().match(/^(\\d+)\\s*[xX]\\s*(\\d+)$/);
        if (!match) return null;
        const width = Number(match[1]);
        const height = Number(match[2]);
        if (!Number.isFinite(width) || !Number.isFinite(height)) {
          return null;
        }
        return { width, height };
      }

      function smoothScroll(container, targetY, duration = 600) {
        const start = container.scrollTop || 0;
        const change = targetY - start;
        const startTime = performance.now();

        return new Promise((resolve) => {
          function step(now) {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = easeInOut(progress);
            container.scrollTop = start + change * eased;
            if (progress < 1) {
              requestAnimationFrame(step);
            } else {
              resolve();
            }
          }
          requestAnimationFrame(step);
        });
      }

      async function withDemoDocument(fn) {
        const win = frame.contentWindow;
        if (!win) throw new Error("iframe not ready");
        const doc = win.document;
        if (!doc || doc.readyState !== "complete") {
          await new Promise((resolve) =>
            frame.addEventListener("load", resolve, { once: true })
          );
        }
        return fn(win.document);
      }

      function getTargetRect(doc, selector) {
        const el = doc.querySelector(selector);
        if (!el) return null;
        const rect = el.getBoundingClientRect();
        const scrollEl = doc.scrollingElement || doc.documentElement;
        const scrollLeft = scrollEl?.scrollLeft ?? 0;
        const scrollTop = scrollEl?.scrollTop ?? 0;
        const frameRect = frame.getBoundingClientRect();
        const shellRect = browserShell?.getBoundingClientRect();
        const offsetTop = shellRect
          ? frameRect.top - shellRect.top
          : frame.offsetTop;
        const offsetLeft = shellRect
          ? frameRect.left - shellRect.left
          : frame.offsetLeft;
        return {
          top: rect.top + offsetTop,
          left: rect.left + offsetLeft,
          width: rect.width,
          height: rect.height,
          contentTop: rect.top + scrollTop,
          contentLeft: rect.left + scrollLeft,
          element: el,
        };
      }

      async function scrollToSelector(selector) {
        return withDemoDocument(async (doc) => {
          const target = doc.querySelector(selector);
          if (!target) {
            console.warn("selector missing", selector);
            return;
          }
          const container = doc.scrollingElement || doc.documentElement;
          const { top } = target.getBoundingClientRect();
          const currentScroll = container.scrollTop || 0;
          const offset = top + currentScroll - 80;
          await smoothScroll(container, Math.max(offset, 0));
          highlightSelector(selector);
        });
      }

      function highlightSelector(selector) {
        withDemoDocument((doc) => {
          const rect = getTargetRect(doc, selector);
          if (!rect) {
            highlight.classList.add("hidden");
            return;
          }
          highlight.style.top = `${rect.top}px`;
          highlight.style.left = `${rect.left}px`;
          highlight.style.width = `${rect.width}px`;
          highlight.style.height = `${rect.height}px`;
          highlight.classList.remove("hidden");
        }).catch(() => {
          highlight.classList.add("hidden");
        });
      }

      function zoomToSelector(selector, opts = {}) {
        return withDemoDocument((doc) => {
          const rect = getTargetRect(doc, selector);
          if (!rect || !browserShell) return;
          const viewportWidth = browserShell.clientWidth ||
            frame.clientWidth;
          const viewportHeight = browserShell.clientHeight ||
            frame.clientHeight;
          const padding = Number.isFinite(opts.padding)
            ? opts.padding
            : 80;
          const targetWidth = rect.width + padding * 2;
          const targetHeight = rect.height + padding * 2;
          let scale = Math.min(
            viewportWidth / targetWidth,
            viewportHeight / targetHeight,
          );
          const maxScale = Number.isFinite(opts.maxScale)
            ? opts.maxScale
            : 2.4;
          scale = Math.min(Math.max(scale, 1), maxScale);
          const targetCenterX = rect.contentLeft + rect.width / 2;
          const targetCenterY = rect.contentTop + rect.height / 2;
          const contentWidth = viewportWidth * scale;
          const contentHeight = viewportHeight * scale;
          const translateX = clamp(
            viewportWidth / 2 - scale * targetCenterX,
            viewportWidth - contentWidth,
            0,
          );
          const translateY = clamp(
            viewportHeight / 2 - scale * targetCenterY,
            viewportHeight - contentHeight,
            0,
          );
          const duration = Number.isFinite(opts.durationMs)
            ? opts.durationMs
            : 700;
          return animateZoom(
            { x: translateX, y: translateY, scale },
            duration,
          );
        });
      }

      function resetZoom(opts = {}) {
        const duration = Number.isFinite(opts.durationMs)
          ? opts.durationMs
          : 500;
        return animateZoom({ x: 0, y: 0, scale: 1 }, duration);
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function getPreferredAudioMimeType() {
        if (!window.MediaRecorder) return "";
        const candidates = [
          "audio/webm;codecs=opus",
          "audio/webm",
          "audio/ogg;codecs=opus",
        ];
        return candidates.find((type) =>
          window.MediaRecorder.isTypeSupported(type)
        ) || "";
      }

      function getPreferredVideoMimeType() {
        if (!window.MediaRecorder) return "";
        const candidates = [
          "video/webm;codecs=vp9",
          "video/webm;codecs=vp8",
          "video/webm",
        ];
        return candidates.find((type) =>
          window.MediaRecorder.isTypeSupported(type)
        ) || "";
      }

      function bufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        const chunkSize = 0x8000;
        let binary = "";
        for (let i = 0; i < bytes.length; i += chunkSize) {
          binary += String.fromCharCode(
            ...bytes.subarray(i, i + chunkSize),
          );
        }
        return btoa(binary);
      }

      async function emitVideoChunk(blob) {
        const handler = window.gambitDemo?.video?.ondata;
        if (typeof handler !== "function") {
          return false;
        }
        const buffer = await blob.arrayBuffer();
        const base64 = bufferToBase64(buffer);
        handler({
          base64,
          mimeType: videoState.mimeType || blob.type,
          size: blob.size,
        });
        return true;
      }

      async function startVideoRecording(opts = {}) {
        if (!window.MediaRecorder) {
          throw new Error("MediaRecorder not available");
        }
        if (videoState.recorder) return;
        const displayStream = await navigator.mediaDevices
          .getDisplayMedia({
            video: {
              frameRate: Number.isFinite(opts.frameRate)
                ? opts.frameRate
                : 60,
            },
            audio: opts.includeAudio === true,
            preferCurrentTab: true,
            selfBrowserSurface: "include",
            surfaceSwitching: "exclude",
            monitorTypeSurfaces: "exclude",
          });
        const sourceStreams = [displayStream];
        let combinedStream = displayStream;
        if (opts.includeMic === true) {
          const micStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          sourceStreams.push(micStream);
          const context = new AudioContext();
          await context.resume().catch(() => {});
          const destination = context.createMediaStreamDestination();
          const streamsToMix = [
            displayStream,
            micStream,
          ];
          streamsToMix.forEach((stream) => {
            if (!stream.getAudioTracks().length) return;
            const source = context.createMediaStreamSource(stream);
            source.connect(destination);
          });
          combinedStream = new MediaStream([
            ...displayStream.getVideoTracks(),
            ...destination.stream.getAudioTracks(),
          ]);
          videoState.audioContext = context;
        }
        const mimeType = getPreferredVideoMimeType();
        const recorder = mimeType
          ? new MediaRecorder(combinedStream, { mimeType })
          : new MediaRecorder(combinedStream);

        videoState.recorder = recorder;
        videoState.chunks = [];
        videoState.stream = combinedStream;
        videoState.sourceStreams = sourceStreams;
        videoState.mimeType = mimeType || recorder.mimeType || "";
        videoState.totalBytes = 0;

        recorder.addEventListener("dataavailable", (event) => {
          if (!event.data || event.data.size === 0) return;
          videoState.totalBytes += event.data.size;
          emitVideoChunk(event.data).then((handled) => {
            if (!handled) {
              videoState.chunks.push(event.data);
            }
          });
        });

        const chunkMs = Number.isFinite(opts.chunkMs)
          ? opts.chunkMs
          : 1000;
        const started = new Promise((resolve) => {
          recorder.addEventListener("start", resolve, { once: true });
        });
        recorder.start(chunkMs);
        await started;
      }

      async function stopVideoRecording() {
        const recorder = videoState.recorder;
        if (!recorder) return null;
        const stopped = new Promise((resolve) => {
          recorder.addEventListener("stop", resolve, { once: true });
        });
        recorder.stop();
        await stopped;
        const handler = window.gambitDemo?.video?.onstop;
        if (typeof handler === "function") {
          handler({
            mimeType: videoState.mimeType || recorder.mimeType ||
              "video/webm",
            size: videoState.totalBytes,
          });
        }
        let result = null;
        if (videoState.chunks.length) {
          const blob = new Blob(videoState.chunks, {
            type: videoState.mimeType || "video/webm",
          });
          const buffer = await blob.arrayBuffer();
          result = {
            mimeType: videoState.mimeType || blob.type,
            base64: bufferToBase64(buffer),
          };
        }
        videoState.sourceStreams.forEach((stream) => {
          stream.getTracks().forEach((track) => track.stop());
        });
        if (videoState.audioContext) {
          await videoState.audioContext.close().catch(() => {});
        }
        videoState.recorder = null;
        videoState.chunks = [];
        videoState.stream = null;
        videoState.sourceStreams = [];
        videoState.audioContext = null;
        videoState.mimeType = "";
        videoState.totalBytes = 0;
        return result;
      }

      async function startAudioRecording(opts = {}) {
        if (!window.MediaRecorder) {
          throw new Error("MediaRecorder not available");
        }
        if (audioState.recorder) return;
        const includeTabAudio = opts.includeTabAudio !== false;
        const includeMic = opts.includeMic === true;
        const streams = [];
        if (includeTabAudio) {
          try {
            const displayStream = await navigator.mediaDevices
              .getDisplayMedia({
                audio: true,
                video: true,
              });
            if (displayStream.getAudioTracks().length) {
              streams.push(displayStream);
            } else {
              displayStream.getTracks().forEach((track) =>
                track.stop()
              );
              console.warn("display capture returned no audio track");
            }
          } catch (error) {
            console.warn("display audio capture failed", error);
          }
        }
        if (includeMic) {
          try {
            const micStream = await navigator.mediaDevices.getUserMedia(
              {
                audio: true,
              },
            );
            if (micStream.getAudioTracks().length) {
              streams.push(micStream);
            } else {
              micStream.getTracks().forEach((track) => track.stop());
              console.warn("mic capture returned no audio track");
            }
          } catch (error) {
            console.warn("mic capture failed", error);
          }
        }
        if (!streams.length) {
          throw new Error("no audio streams available");
        }
        const context = new AudioContext();
        await context.resume().catch(() => {});
        const destination = context.createMediaStreamDestination();
        streams.forEach((stream) => {
          if (!stream.getAudioTracks().length) return;
          const source = context.createMediaStreamSource(stream);
          source.connect(destination);
        });

        const mimeType = getPreferredAudioMimeType();
        const recorder = mimeType
          ? new MediaRecorder(destination.stream, { mimeType })
          : new MediaRecorder(destination.stream);

        audioState.recorder = recorder;
        audioState.chunks = [];
        audioState.streams = streams;
        audioState.context = context;
        audioState.mimeType = mimeType || recorder.mimeType || "";

        recorder.addEventListener("dataavailable", (event) => {
          if (event.data && event.data.size > 0) {
            audioState.chunks.push(event.data);
          }
        });
        recorder.start(1000);
      }

      async function stopAudioRecording() {
        const recorder = audioState.recorder;
        if (!recorder) return null;
        const stopped = new Promise((resolve) => {
          recorder.addEventListener("stop", resolve, { once: true });
        });
        recorder.stop();
        await stopped;
        const blob = new Blob(audioState.chunks, {
          type: audioState.mimeType || "audio/webm",
        });
        const buffer = await blob.arrayBuffer();
        const base64 = bufferToBase64(buffer);
        audioState.streams.forEach((stream) => {
          stream.getTracks().forEach((track) => track.stop());
        });
        if (audioState.context) {
          await audioState.context.close().catch(() => {});
        }
        const result = {
          mimeType: audioState.mimeType || blob.type,
          base64,
        };
        audioState.recorder = null;
        audioState.chunks = [];
        audioState.streams = [];
        audioState.context = null;
        audioState.mimeType = "";
        return result;
      }

      window.gambitDemo = {
        zoomTo: (selector, opts) => zoomToSelector(selector, opts),
        resetZoom: (opts) => resetZoom(opts),
        scrollTo: (selector) => scrollToSelector(selector),
        highlight: (selector) => highlightSelector(selector),
        audio: {
          startRecording: (opts) => startAudioRecording(opts),
          stopRecording: () => stopAudioRecording(),
        },
        video: {
          startRecording: (opts) => startVideoRecording(opts),
          stopRecording: () => stopVideoRecording(),
          ondata: null,
          onstop: null,
        },
      };

      document.addEventListener("click", (event) => {
        const button = event.target.closest("button[data-action]");
        if (!button) return;
        const action = button.dataset.action;
        const selector = button.dataset.target;
        if (action === "scroll") {
          if (!selector) return;
          scrollToSelector(selector);
        } else if (action === "highlight") {
          if (!selector) return;
          highlightSelector(selector);
        } else if (action === "zoom") {
          if (!selector) return;
          zoomToSelector(selector);
        } else if (action === "zoom-reset") {
          resetZoom();
        }
      });
    </script>
  </body>
</html>
