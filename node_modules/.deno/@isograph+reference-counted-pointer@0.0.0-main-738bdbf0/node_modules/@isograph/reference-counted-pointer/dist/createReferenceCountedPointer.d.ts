import type { ItemCleanupPair } from '@isograph/disposable-types';
/**
 * Create an undisposed reference-counted pointer guarding a given item.
 *
 * Once all reference-counted pointers guarding a given item have been
 * disposed, the underlying item will be disposed.
 *
 * Additional reference-counted pointers guarding the same item can be
 * created by calling cloneIfNotDisposed().
 *
 * ## Structural sharing
 *
 * Reference counted pointers enable reusing disposable items between
 * application states, so-called structural sharing.
 *
 * If state 1 contains a reference counted pointer to an item, in order
 * to transition to state 2, one would first create an additional
 * reference-counted pointer by calling cloneIfNotDisposed, transition
 * to state 2, then clean up state 1 by disposing of its reference-
 * counted pointers. In this transition, at no time were there zero
 * undisposed reference countend pointers to the disposable item, so it
 * was never disposed, and we could reuse it between states.
 */
export declare function createReferenceCountedPointer<T>(pair: ItemCleanupPair<T>): ItemCleanupPair<ReferenceCountedPointer<T>>;
export interface ReferenceCountedPointer<T> {
    isDisposed(): boolean;
    /**
     * Safety: the item returned here is valid for use only as long as the reference
     * counted pointer is not disposed.
     */
    getItemIfNotDisposed(): T | null;
    cloneIfNotDisposed(): ItemCleanupPair<ReferenceCountedPointer<T>> | null;
}
//# sourceMappingURL=createReferenceCountedPointer.d.ts.map