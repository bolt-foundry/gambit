import { ItemCleanupPair } from '@isograph/disposable-types';
export declare const UNASSIGNED_STATE: unique symbol;
export type UnassignedState = typeof UNASSIGNED_STATE;
type UseUpdatableDisposableStateReturnValue<T> = {
    state: T | UnassignedState;
    setState: (pair: ItemCleanupPair<Exclude<T, UnassignedState>>) => void;
};
/**
 * useUpdatableDisposableState
 * - Returns a { state, setItem } object.
 * - setItem accepts an ItemCleanupPair<T>, and throws if called before commit.
 * - setItem sets the T in state and adds it to a set.
 * - React's behavior is that when the hook commits, whatever item is currently
 *   returned from the useState hook is the oldest item which will ever be returned
 *   from that useState hook. (More newly created ones can later be returned with
 *   concurrent mode.)
 * - When this hook commits, all items up to, but not including, the item currently
 *   returned from the useState hook are disposed and removed from the set.
 *
 * Calling setState before the hook commits:
 * - Calling setState before the hook commits is disallowed because until the hook
 *   commits, React will not schedule any unmount callbacks, meaning that if this
 *   hook never commits, any disposable items passed to setState will never be
 *   disposed.
 * - We also cannot store them in some cache, because multiple components can share
 *   the same cache location (for example, if they are loading the same query from
 *   multiple components), so updating the cache with the disposable item will cause
 *   both components to show the updated data, which is almost certainly a bug.
 * - Note that calling setState before commit is probably an anti-pattern! Consider
 *   not doing it.
 * - If you must, the workaround is to lazily load the disposable item with
 *   useDisposableState or useLazyDisposableState, and update the cache location
 *   instead of calling setState before commit. One can update the cache location
 *   by calling setState on some parent component that has already mounted, and
 *   therefore passing in different props.
 *   - This may only work in concurrent mode, though.
 */
export declare function useUpdatableDisposableState<T = never>(): UseUpdatableDisposableStateReturnValue<T>;
export {};
//# sourceMappingURL=useUpdatableDisposableState.d.ts.map