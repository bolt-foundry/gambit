import { CleanupFn, Factory, ItemCleanupPair } from '@isograph/disposable-types';
export type NotInParentCacheAndDisposed = {
    kind: 'NotInParentCacheAndDisposed';
};
export type NotInParentCacheAndNotDisposed<T> = {
    kind: 'NotInParentCacheAndNotDisposed';
    value: T;
    disposeValue: () => void;
    permanentRetainCount: number;
};
export type InParentCacheAndNotDisposed<T> = {
    kind: 'InParentCacheAndNotDisposed';
    value: T;
    disposeValue: () => void;
    removeFromParentCache: () => void;
    temporaryRetainCount: number;
    permanentRetainCount: number;
};
export type CacheItemState<T> = InParentCacheAndNotDisposed<T> | NotInParentCacheAndNotDisposed<T> | NotInParentCacheAndDisposed;
export type CacheItemOptions = {
    temporaryRetainTime: number;
};
/**
 * CacheItem:
 *
 * Terminology:
 * - TRC = Temporary Retain Count
 * - PRC = Permanent Retain Count
 *
 * A CacheItem<T> can be in three states:
 *   In parent cache? | Item disposed? | TRC | PRC | Name
 *   -----------------+----------------+-----+-----+-------------------------------
 *   In parent cache  | Not disposed   | >0  | >=0 | InParentCacheAndNotDisposed
 *   Removed          | Not disposed   |  0  |  >0 | NotInParentCacheAndNotDisposed
 *   Removed          | Disposed       |  0  |   0 | NotInParentCacheAndNotDisposed
 *
 * A cache item can only move down rows. As in, if its in the parent cache,
 * it can be removed. It can never be replaced in the parent cache. (If a
 * parent cache becomes full again, it will contain a new CacheItem.) The
 * contained item can be disposed, but never un-disposed.
 *
 * So, the valid transitions are:
 * - InParentCacheAndNotDisposed => NotInParentCacheAndNotDisposed
 * - InParentCacheAndNotDisposed => NotInParentCacheAndDisposed
 * - NotInParentCacheAndNotDisposed => NotInParentCacheAndDisposed
 */
export declare class CacheItem<T> {
    private __state;
    private __options;
    constructor(factory: Factory<T>, removeFromParentCache: CleanupFn, options: CacheItemOptions | void);
    getValue(): T;
    permanentRetainIfNotDisposed(disposeOfTemporaryRetain: CleanupFn): ItemCleanupPair<T> | null;
    temporaryRetain(): CleanupFn;
    permanentRetain(): CleanupFn;
    private __maybeExitInParentCacheAndNotDisposedState;
    private __maybeExitNotInParentCacheAndNotDisposedState;
}
export declare function createTemporarilyRetainedCacheItem<T>(factory: Factory<T>, removeFromParentCache: CleanupFn, options: CacheItemOptions | void): [CacheItem<T>, CleanupFn];
//# sourceMappingURL=CacheItem.d.ts.map