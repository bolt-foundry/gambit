import { CleanupFn, Factory, ItemCleanupPair } from '@isograph/disposable-types';
import { CacheItem } from './CacheItem';
/**
 * ParentCache
 * - A ParentCache can be in two states: populated and unpopulated.
 * - A ParentCache holds a CacheItem, which can choose to remove itself from
 *   the parent ParentCache.
 * - If the ParentCache is populated, the CacheItem (i.e. this.__value) must be
 *   in the InParentCacheAndNotDisposed state, i.e. not disposed, so after we
 *   null-check this.__value, this.__value.getValue(), this.__value.temporaryRetain()
 *   and this.__value.permanentRetain() are safe to be called.
 *
 * - Though we do not do so, it is always safe to call parentCache.delete().
 *
 * Invariant:
 * - A parent cache at a given "location" (conceptually, an ID) should always
 *   be called
 */
export declare class ParentCache<T> {
    private __cacheItem;
    private readonly __factory;
    constructor(factory: Factory<T>);
    /**
     * This is called from useCachedResponsivePrecommitValue, when the parent cache is populated
     * and a previous temporary retain has been disposed. This can occur in scenarios like:
     * - temporary retain A is created by component B rendering
     * - temporary retain A expires, emptying the parent cache
     * - another component renders, sharing the same parent cache, filling
     *   by calling getOrPopulateAndTemporaryRetain
     * - component B commits. We see that temporary retain A has been disposed,
     *   and re-check the parent cache by calling this method.
     */
    getAndPermanentRetainIfPresent(): ItemCleanupPair<T> | null;
    getOrPopulateAndTemporaryRetain(): [CacheItem<T>, T, CleanupFn];
    private __populateAndTemporaryRetain;
    empty(): void;
    get factory(): Factory<T>;
    isEmpty(): boolean;
}
//# sourceMappingURL=ParentCache.d.ts.map