"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UNASSIGNED_STATE = void 0;
exports.useUpdatableDisposableState = useUpdatableDisposableState;
const react_1 = require("react");
const useHasCommittedRef_1 = require("./useHasCommittedRef");
exports.UNASSIGNED_STATE = Symbol();
/**
 * useUpdatableDisposableState
 * - Returns a { state, setItem } object.
 * - setItem accepts an ItemCleanupPair<T>, and throws if called before commit.
 * - setItem sets the T in state and adds it to a set.
 * - React's behavior is that when the hook commits, whatever item is currently
 *   returned from the useState hook is the oldest item which will ever be returned
 *   from that useState hook. (More newly created ones can later be returned with
 *   concurrent mode.)
 * - When this hook commits, all items up to, but not including, the item currently
 *   returned from the useState hook are disposed and removed from the set.
 *
 * Calling setState before the hook commits:
 * - Calling setState before the hook commits is disallowed because until the hook
 *   commits, React will not schedule any unmount callbacks, meaning that if this
 *   hook never commits, any disposable items passed to setState will never be
 *   disposed.
 * - We also cannot store them in some cache, because multiple components can share
 *   the same cache location (for example, if they are loading the same query from
 *   multiple components), so updating the cache with the disposable item will cause
 *   both components to show the updated data, which is almost certainly a bug.
 * - Note that calling setState before commit is probably an anti-pattern! Consider
 *   not doing it.
 * - If you must, the workaround is to lazily load the disposable item with
 *   useDisposableState or useLazyDisposableState, and update the cache location
 *   instead of calling setState before commit. One can update the cache location
 *   by calling setState on some parent component that has already mounted, and
 *   therefore passing in different props.
 *   - This may only work in concurrent mode, though.
 */
function useUpdatableDisposableState() {
    const hasCommittedRef = (0, useHasCommittedRef_1.useHasCommittedRef)();
    const undisposedICIs = (0, react_1.useRef)(new Set());
    const setStateCountRef = (0, react_1.useRef)(0);
    const [stateICI, setStateICI] = (0, react_1.useState)(exports.UNASSIGNED_STATE);
    const setStateAfterCommit = (0, react_1.useCallback)((itemCleanupPair) => {
        if (!hasCommittedRef.current) {
            throw new Error('Calling setState before the component has committed is unsafe and disallowed.');
        }
        const ici = {
            item: itemCleanupPair[0],
            cleanup: itemCleanupPair[1],
            index: setStateCountRef.current,
        };
        setStateCountRef.current++;
        undisposedICIs.current.add(ici);
        setStateICI(ici);
    }, [setStateICI]);
    (0, react_1.useEffect)(function cleanupUnreachableItems() {
        const indexInState = stateICI !== exports.UNASSIGNED_STATE ? stateICI.index : 0;
        if (indexInState === 0) {
            return;
        }
        for (const undisposedICI of undisposedICIs.current) {
            if (undisposedICI.index === indexInState) {
                break;
            }
            undisposedICIs.current.delete(undisposedICI);
            undisposedICI.cleanup();
        }
    });
    (0, react_1.useEffect)(() => {
        return function disposeAllRemainingItems() {
            for (const undisposedICI of undisposedICIs.current) {
                undisposedICI.cleanup();
            }
        };
    }, []);
    return {
        setState: setStateAfterCommit,
        state: stateICI !== exports.UNASSIGNED_STATE ? stateICI.item : exports.UNASSIGNED_STATE,
    };
}
// @ts-ignore
function tsTests() {
    const a = useUpdatableDisposableState();
    // @ts-expect-error
    a.setState([exports.UNASSIGNED_STATE, () => { }]);
    // @ts-expect-error
    a.setState(['asdf', () => { }]);
    const b = useUpdatableDisposableState();
    // @ts-expect-error
    b.setState([exports.UNASSIGNED_STATE, () => { }]);
    b.setState(['asdf', () => { }]);
}
