"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheItem = void 0;
exports.createTemporarilyRetainedCacheItem = createTemporarilyRetainedCacheItem;
const DEFAULT_TEMPORARY_RETAIN_TIME = 5000;
// TODO don't export this class, only export type (interface) instead
// TODO convert cacheitem impl to a getter and setter and free functions
/**
 * CacheItem:
 *
 * Terminology:
 * - TRC = Temporary Retain Count
 * - PRC = Permanent Retain Count
 *
 * A CacheItem<T> can be in three states:
 *   In parent cache? | Item disposed? | TRC | PRC | Name
 *   -----------------+----------------+-----+-----+-------------------------------
 *   In parent cache  | Not disposed   | >0  | >=0 | InParentCacheAndNotDisposed
 *   Removed          | Not disposed   |  0  |  >0 | NotInParentCacheAndNotDisposed
 *   Removed          | Disposed       |  0  |   0 | NotInParentCacheAndNotDisposed
 *
 * A cache item can only move down rows. As in, if its in the parent cache,
 * it can be removed. It can never be replaced in the parent cache. (If a
 * parent cache becomes full again, it will contain a new CacheItem.) The
 * contained item can be disposed, but never un-disposed.
 *
 * So, the valid transitions are:
 * - InParentCacheAndNotDisposed => NotInParentCacheAndNotDisposed
 * - InParentCacheAndNotDisposed => NotInParentCacheAndDisposed
 * - NotInParentCacheAndNotDisposed => NotInParentCacheAndDisposed
 */
class CacheItem {
    // Private. Do not call this constructor directly. Use
    // createTemporarilyRetainedCacheItem instead. This is because this
    // constructor creates a CacheItem in an invalid state. It must be
    // temporarily retained to enter a valid state, and JavaScript doesn't
    // let you return a tuple from a constructor.
    constructor(factory, removeFromParentCache, options) {
        this.__options = options !== null && options !== void 0 ? options : null;
        const [value, disposeValue] = factory();
        this.__state = {
            kind: 'InParentCacheAndNotDisposed',
            value,
            disposeValue,
            removeFromParentCache,
            // NOTE: we are creating the CacheItem in an invalid state. This is okay, because
            // we are immediately calling .temporaryRetain.
            temporaryRetainCount: 0,
            permanentRetainCount: 0,
        };
    }
    getValue() {
        switch (this.__state.kind) {
            case 'InParentCacheAndNotDisposed': {
                return this.__state.value;
            }
            case 'NotInParentCacheAndNotDisposed': {
                return this.__state.value;
            }
            default: {
                throw new Error('Attempted to access disposed value from CacheItem. ' +
                    'This indicates a bug in react-disposable-state.');
            }
        }
    }
    permanentRetainIfNotDisposed(disposeOfTemporaryRetain) {
        switch (this.__state.kind) {
            case 'InParentCacheAndNotDisposed': {
                let cleared = false;
                this.__state.permanentRetainCount++;
                disposeOfTemporaryRetain();
                return [
                    this.__state.value,
                    () => {
                        if (cleared) {
                            throw new Error('A permanent retain should only be cleared once. ' +
                                'This indicates a bug in react-disposable-state.');
                        }
                        cleared = true;
                        switch (this.__state.kind) {
                            case 'InParentCacheAndNotDisposed': {
                                this.__state.permanentRetainCount--;
                                this.__maybeExitInParentCacheAndNotDisposedState(this.__state);
                                return;
                            }
                            case 'NotInParentCacheAndNotDisposed': {
                                this.__state.permanentRetainCount--;
                                this.__maybeExitNotInParentCacheAndNotDisposedState(this.__state);
                                return;
                            }
                            default: {
                                throw new Error('CacheItem was in a disposed state, but there existed a permanent retain. ' +
                                    'This indicates a bug in react-disposable-state.');
                            }
                        }
                    },
                ];
            }
            case 'NotInParentCacheAndNotDisposed': {
                let cleared = false;
                this.__state.permanentRetainCount++;
                disposeOfTemporaryRetain();
                return [
                    this.__state.value,
                    () => {
                        if (cleared) {
                            throw new Error('A permanent retain should only be cleared once. ' +
                                'This indicates a bug in react-disposable-state.');
                        }
                        cleared = true;
                        switch (this.__state.kind) {
                            case 'NotInParentCacheAndNotDisposed': {
                                this.__state.permanentRetainCount--;
                                this.__maybeExitNotInParentCacheAndNotDisposedState(this.__state);
                                return;
                            }
                            default: {
                                throw new Error('CacheItem was in an unexpected state. ' +
                                    'This indicates a bug in react-disposable-state.');
                            }
                        }
                    },
                ];
            }
            default: {
                // The CacheItem is disposed, so disposeOfTemporaryRetain is a no-op
                return null;
            }
        }
    }
    temporaryRetain() {
        var _a, _b;
        switch (this.__state.kind) {
            case 'InParentCacheAndNotDisposed': {
                let status = 'Uncleared';
                this.__state.temporaryRetainCount++;
                const clearTemporaryRetainByCallack = () => {
                    if (status === 'ClearedByCallback') {
                        throw new Error('A temporary retain should only be cleared once. ' +
                            'This indicates a bug in react-disposable-state.');
                    }
                    else if (status === 'Uncleared') {
                        switch (this.__state.kind) {
                            case 'InParentCacheAndNotDisposed': {
                                this.__state.temporaryRetainCount--;
                                this.__maybeExitInParentCacheAndNotDisposedState(this.__state);
                                clearTimeout(timeoutId);
                                return;
                            }
                            default: {
                                throw new Error('A temporary retain was cleared, for which the CacheItem is in an invalid state. ' +
                                    'This indicates a bug in react-disposable-state.');
                            }
                        }
                    }
                };
                const clearTemporaryRetainByTimeout = () => {
                    status = 'ClearedByTimeout';
                    switch (this.__state.kind) {
                        case 'InParentCacheAndNotDisposed': {
                            this.__state.temporaryRetainCount--;
                            this.__maybeExitInParentCacheAndNotDisposedState(this.__state);
                            return;
                        }
                        default: {
                            throw new Error('A temporary retain was cleared, for which the CacheItem is in an invalid state. ' +
                                'This indicates a bug in react-disposable-state.');
                        }
                    }
                };
                const timeoutId = setTimeout(clearTemporaryRetainByTimeout, (_b = (_a = this.__options) === null || _a === void 0 ? void 0 : _a.temporaryRetainTime) !== null && _b !== void 0 ? _b : DEFAULT_TEMPORARY_RETAIN_TIME);
                return clearTemporaryRetainByCallack;
            }
            default: {
                throw new Error('temporaryRetain was called, for which the CacheItem is in an invalid state. ' +
                    'This indicates a bug in react-disposable-state.');
            }
        }
    }
    permanentRetain() {
        switch (this.__state.kind) {
            case 'InParentCacheAndNotDisposed': {
                let cleared = false;
                this.__state.permanentRetainCount++;
                return () => {
                    if (cleared) {
                        throw new Error('A permanent retain should only be cleared once. ' +
                            'This indicates a bug in react-disposable-state.');
                    }
                    cleared = true;
                    switch (this.__state.kind) {
                        case 'InParentCacheAndNotDisposed': {
                            this.__state.permanentRetainCount--;
                            this.__maybeExitInParentCacheAndNotDisposedState(this.__state);
                            return;
                        }
                        case 'NotInParentCacheAndNotDisposed': {
                            this.__state.permanentRetainCount--;
                            this.__maybeExitNotInParentCacheAndNotDisposedState(this.__state);
                            return;
                        }
                        default: {
                            throw new Error('CacheItem was in a disposed state, but there existed a permanent retain. ' +
                                'This indicates a bug in react-disposable-state.');
                        }
                    }
                };
            }
            case 'NotInParentCacheAndNotDisposed': {
                let cleared = false;
                this.__state.permanentRetainCount++;
                return () => {
                    if (cleared) {
                        throw new Error('A permanent retain should only be cleared once. ' +
                            'This indicates a bug in react-disposable-state.');
                    }
                    cleared = true;
                    switch (this.__state.kind) {
                        case 'NotInParentCacheAndNotDisposed': {
                            this.__state.permanentRetainCount--;
                            this.__maybeExitNotInParentCacheAndNotDisposedState(this.__state);
                            return;
                        }
                        default: {
                            throw new Error('CacheItem was in an unexpected state. ' +
                                'This indicates a bug in react-disposable-state.');
                        }
                    }
                };
            }
            default: {
                throw new Error('permanentRetain was called, but the CacheItem is in an invalid state. ' +
                    'This indicates a bug in react-disposable-state.');
            }
        }
    }
    __maybeExitInParentCacheAndNotDisposedState(state) {
        if (state.temporaryRetainCount === 0 && state.permanentRetainCount === 0) {
            state.removeFromParentCache();
            state.disposeValue();
            this.__state = {
                kind: 'NotInParentCacheAndDisposed',
            };
        }
        else if (state.temporaryRetainCount === 0) {
            state.removeFromParentCache();
            this.__state = {
                kind: 'NotInParentCacheAndNotDisposed',
                value: state.value,
                disposeValue: state.disposeValue,
                permanentRetainCount: state.permanentRetainCount,
            };
        }
    }
    __maybeExitNotInParentCacheAndNotDisposedState(state) {
        if (state.permanentRetainCount === 0) {
            state.disposeValue();
            this.__state = {
                kind: 'NotInParentCacheAndDisposed',
            };
        }
    }
}
exports.CacheItem = CacheItem;
function createTemporarilyRetainedCacheItem(factory, removeFromParentCache, options) {
    const cacheItem = new CacheItem(factory, removeFromParentCache, options);
    const disposeTemporaryRetain = cacheItem.temporaryRetain();
    return [cacheItem, disposeTemporaryRetain];
}
