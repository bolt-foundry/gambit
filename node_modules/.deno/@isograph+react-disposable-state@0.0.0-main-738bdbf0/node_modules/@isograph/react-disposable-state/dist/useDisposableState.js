"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDisposableState = useDisposableState;
const react_1 = require("react");
const useCachedResponsivePrecommitValue_1 = require("./useCachedResponsivePrecommitValue");
const useUpdatableDisposableState_1 = require("./useUpdatableDisposableState");
function useDisposableState(parentCache) {
    var _a, _b, _c;
    const itemCleanupPairRef = (0, react_1.useRef)(null);
    const preCommitItem = (0, useCachedResponsivePrecommitValue_1.useCachedResponsivePrecommitValue)(parentCache, (pair) => {
        var _a;
        (_a = itemCleanupPairRef.current) === null || _a === void 0 ? void 0 : _a[1]();
        itemCleanupPairRef.current = pair;
    });
    const { state: stateFromDisposableStateHook, setState } = (0, useUpdatableDisposableState_1.useUpdatableDisposableState)();
    (0, react_1.useEffect)(function cleanupItemCleanupPairRefAfterSetState() {
        if (stateFromDisposableStateHook !== useUpdatableDisposableState_1.UNASSIGNED_STATE) {
            if (itemCleanupPairRef.current !== null) {
                itemCleanupPairRef.current[1]();
                itemCleanupPairRef.current = null;
            }
            else {
                throw new Error('itemCleanupPairRef.current is unexpectedly null. ' +
                    'This indicates a bug in react-disposable-state.');
            }
        }
    }, [stateFromDisposableStateHook]);
    (0, react_1.useEffect)(function cleanupItemCleanupPairRefIfSetStateNotCalled() {
        return () => {
            if (itemCleanupPairRef.current !== null) {
                itemCleanupPairRef.current[1]();
                itemCleanupPairRef.current = null;
            }
        };
    }, []);
    // Safety: we can be in one of three states. Pre-commit, in which case
    // preCommitItem is assigned, post-commit but before setState has been
    // called, in which case itemCleanupPairRef.current is assigned, or
    // after setState has been called, in which case
    // stateFromDisposableStateHook is assigned.
    //
    // Therefore, the type of state is T, not T | undefined. But the fact
    // that we are in one of the three states is not reflected in the types.
    // So we have to cast to T.
    //
    // Note that in the post-commit post-setState state, itemCleanupPairRef
    // can still be assigned, during the render before the
    // cleanupItemCleanupPairRefAfterSetState effect is called.
    const state = (_b = (_a = (stateFromDisposableStateHook != useUpdatableDisposableState_1.UNASSIGNED_STATE
        ? stateFromDisposableStateHook
        : null)) !== null && _a !== void 0 ? _a : preCommitItem === null || preCommitItem === void 0 ? void 0 : preCommitItem.state) !== null && _b !== void 0 ? _b : (_c = itemCleanupPairRef.current) === null || _c === void 0 ? void 0 : _c[0];
    return {
        state: state,
        setState,
    };
}
// @ts-ignore
function tsTests() {
    let x;
    const a = useDisposableState(x);
    // This should be a compiler error, because the generic is inferred to be of
    // type never. TODO determine why this doesn't break the build!
    // @ts-expect-error
    a.setState(['asdf', () => { }]);
    // @ts-expect-error
    a.setState([useUpdatableDisposableState_1.UNASSIGNED_STATE, () => { }]);
    const b = useDisposableState(x);
    // @ts-expect-error
    b.setState([useUpdatableDisposableState_1.UNASSIGNED_STATE, () => { }]);
    b.setState(['asdf', () => { }]);
}
