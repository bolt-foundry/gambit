"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useResult = useResult;
exports.maybeUnwrapNetworkRequest = maybeUnwrapNetworkRequest;
const componentCache_1 = require("../core/componentCache");
const PromiseWrapper_1 = require("../core/PromiseWrapper");
const read_1 = require("../core/read");
const startUpdate_1 = require("../core/startUpdate");
const IsographEnvironmentProvider_1 = require("../react/IsographEnvironmentProvider");
const useReadAndSubscribe_1 = require("./useReadAndSubscribe");
function useResult(fragmentReference, partialNetworkRequestOptions) {
    const environment = (0, IsographEnvironmentProvider_1.useIsographEnvironment)();
    const networkRequestOptions = (0, read_1.getNetworkRequestOptionsWithDefaults)(partialNetworkRequestOptions);
    maybeUnwrapNetworkRequest(fragmentReference.networkRequest, networkRequestOptions);
    const readerWithRefetchQueries = (0, PromiseWrapper_1.readPromise)(fragmentReference.readerWithRefetchQueries);
    switch (readerWithRefetchQueries.readerArtifact.kind) {
        case 'ComponentReaderArtifact': {
            // @ts-expect-error
            return (0, componentCache_1.getOrCreateCachedComponent)(environment, readerWithRefetchQueries.readerArtifact.fieldName, fragmentReference, networkRequestOptions);
        }
        case 'EagerReaderArtifact': {
            const data = (0, useReadAndSubscribe_1.useReadAndSubscribe)(fragmentReference, networkRequestOptions, readerWithRefetchQueries.readerArtifact.readerAst);
            const param = Object.assign({ data: data, parameters: fragmentReference.variables }, (readerWithRefetchQueries.readerArtifact.hasUpdatable
                ? {
                    startUpdate: (0, startUpdate_1.getOrCreateCachedStartUpdate)(environment, fragmentReference, readerWithRefetchQueries.readerArtifact.fieldName, networkRequestOptions),
                }
                : undefined));
            return readerWithRefetchQueries.readerArtifact.resolver(param);
        }
    }
}
function maybeUnwrapNetworkRequest(networkRequest, networkRequestOptions) {
    const state = (0, PromiseWrapper_1.getPromiseState)(networkRequest);
    if (state.kind === 'Err' && networkRequestOptions.throwOnNetworkError) {
        throw state.error;
    }
    else if (state.kind === 'Pending' &&
        networkRequestOptions.suspendIfInFlight) {
        throw state.promise;
    }
}
