"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useLazyReference = useLazyReference;
const react_disposable_state_1 = require("@isograph/react-disposable-state");
const cache_1 = require("../core/cache");
const logging_1 = require("../core/logging");
const IsographEnvironmentProvider_1 = require("./IsographEnvironmentProvider");
function useLazyReference(entrypoint, variables, ...[fetchOptions]) {
    const environment = (0, IsographEnvironmentProvider_1.useIsographEnvironment)();
    if ((entrypoint === null || entrypoint === void 0 ? void 0 : entrypoint.kind) !== 'Entrypoint') {
        // TODO have a separate error logger
        (0, logging_1.logMessage)(environment, () => ({
            kind: 'NonEntrypointReceived',
            entrypoint,
        }));
    }
    const cache = (0, cache_1.getOrCreateCacheForArtifact)(environment, entrypoint, variables, fetchOptions);
    return {
        fragmentReference: (0, react_disposable_state_1.useLazyDisposableState)(cache).state,
    };
}
// @ts-ignore
function tsTests() {
    let withAst;
    let withAstLoader;
    let withAstOrLoader;
    useLazyReference(withAst, {});
    useLazyReference(withAst, {}, { shouldFetch: 'Yes' });
    useLazyReference(withAst, {}, { shouldFetch: 'IfNecessary' });
    // @ts-expect-error if there's no ast, require `shouldFetch` to be specified
    useLazyReference(withAstLoader, {});
    useLazyReference(withAstLoader, {}, { shouldFetch: 'Yes' });
    // @ts-expect-error if there's no ast, `shouldFetch` can't be `IfNecessary`
    useLazyReference(withAstLoader, {}, { shouldFetch: 'IfNecessary' });
    // if the type is unknown there can be no ast so we should use the same rules
    // but because of TS bugs with inference we just return unknown
    // @ts-expect-error this returns unknown which doesn't satisfy the constraint
    useLazyReference(withAstOrLoader, {});
    // @ts-expect-error this returns unknown which doesn't satisfy the constraint
    useLazyReference(withAstOrLoader, {}, { shouldFetch: 'Yes' });
    useLazyReference(withAstOrLoader, {}, { shouldFetch: 'IfNecessary' });
}
