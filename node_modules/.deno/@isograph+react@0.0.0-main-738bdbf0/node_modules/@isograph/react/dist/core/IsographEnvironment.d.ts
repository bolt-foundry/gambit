import { ParentCache } from '@isograph/react-disposable-state';
import { IsographEntrypoint, IsographOperation, IsographPersistedOperation } from './entrypoint';
import { FragmentReference, Variables, type StableIdForFragmentReference, type UnknownTReadFromStore } from './FragmentReference';
import { RetainedQuery } from './garbageCollection';
import { LogFunction, WrappedLogFunction } from './logging';
import { PromiseWrapper } from './PromiseWrapper';
import { WithEncounteredRecords } from './read';
import type { ReaderAst, StartUpdate } from './reader';
import type { Brand } from './brand';
export type ComponentOrFieldName = string;
export type StringifiedArgs = string;
export type FieldCache<T> = {
    [key: StableIdForFragmentReference]: T;
};
export type FragmentSubscription<TReadFromStore extends UnknownTReadFromStore> = {
    readonly kind: 'FragmentSubscription';
    readonly callback: (newEncounteredDataAndRecords: WithEncounteredRecords<TReadFromStore>) => void;
    /** The value read out from the previous call to readButDoNotEvaluate */
    encounteredDataAndRecords: WithEncounteredRecords<TReadFromStore>;
    readonly fragmentReference: FragmentReference<TReadFromStore, any>;
    readonly readerAst: ReaderAst<TReadFromStore>;
};
export type AnyChangesToRecordSubscription = {
    readonly kind: 'AnyChangesToRecord';
    readonly callback: () => void;
    readonly recordLink: StoreLink;
};
export type AnyRecordSubscription = {
    readonly kind: 'AnyRecords';
    readonly callback: () => void;
};
export type Subscription = FragmentSubscription<any> | AnyChangesToRecordSubscription | AnyRecordSubscription;
export type Subscriptions = Set<Subscription>;
export type CacheMap<T> = {
    [index: string]: ParentCache<T>;
};
export type IsographEnvironment = {
    readonly store: IsographStore;
    readonly networkFunction: IsographNetworkFunction;
    readonly missingFieldHandler: MissingFieldHandler | null;
    readonly componentCache: FieldCache<React.FC<any>>;
    readonly eagerReaderCache: FieldCache<StartUpdate<any> | undefined>;
    readonly subscriptions: Subscriptions;
    readonly fragmentCache: CacheMap<FragmentReference<any, any>>;
    readonly entrypointArtifactCache: Map<string, PromiseWrapper<IsographEntrypoint<any, any, any>>>;
    readonly retainedQueries: Set<RetainedQuery>;
    readonly gcBuffer: Array<RetainedQuery>;
    readonly gcBufferSize: number;
    readonly loggers: Set<WrappedLogFunction>;
};
export type MissingFieldHandler = (storeRecord: StoreRecord, root: StoreLink, fieldName: string, arguments_: {
    [index: string]: any;
} | null, variables: Variables | null) => StoreLink | undefined;
export type IsographNetworkFunction = (operation: IsographOperation | IsographPersistedOperation, variables: Variables) => Promise<any>;
export interface Link<T extends TypeName> extends StoreLink {
    readonly __link: Brand<DataId, T>;
    readonly __typename: T;
}
export type StoreLink = {
    readonly __link: DataId;
    readonly __typename: TypeName;
};
export type DataTypeValue = undefined | number | boolean | string | null | StoreLink | DataTypeValue[];
export type StoreRecord = {
    [index: DataId | string]: DataTypeValue;
    readonly id?: DataId;
};
export type TypeName = string;
export type DataId = string;
export declare const ROOT_ID: DataId & '__ROOT';
export type IsographStore = {
    [index: TypeName]: {
        [index: DataId]: StoreRecord | null;
    } | null;
    readonly Query: {
        readonly __ROOT: StoreRecord;
    };
};
export declare function createIsographEnvironment(store: IsographStore, networkFunction: IsographNetworkFunction, missingFieldHandler?: MissingFieldHandler | null, logFunction?: LogFunction | null): IsographEnvironment;
export declare function createIsographStore(): IsographStore;
export declare function assertLink(link: DataTypeValue): StoreLink | null | undefined;
export declare function getLink(maybeLink: DataTypeValue): StoreLink | null;
export declare function getOrLoadIsographArtifact(environment: IsographEnvironment, key: string, loader: () => Promise<IsographEntrypoint<any, any, any>>): PromiseWrapper<IsographEntrypoint<any, any, any>>;
//# sourceMappingURL=IsographEnvironment.d.ts.map