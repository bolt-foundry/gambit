"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeObjectsUsingReaderAst = mergeObjectsUsingReaderAst;
function mergeUsingReaderAst(field, oldItem, newItem) {
    if (newItem === null) {
        return oldItem === null ? oldItem : newItem;
    }
    if (newItem === undefined) {
        return oldItem === undefined ? oldItem : newItem;
    }
    if (Array.isArray(newItem)) {
        if (!Array.isArray(oldItem)) {
            return newItem;
        }
        return mergeArraysUsingReaderAst(field, oldItem, newItem);
    }
    switch (field.kind) {
        case 'Scalar':
            return oldItem === newItem ? oldItem : newItem;
        case 'Linked':
            if (oldItem == null) {
                return newItem;
            }
            return mergeObjectsUsingReaderAst(field.selections, oldItem, newItem);
        default: {
            // Ensure we have covered all variants
            let _ = field;
            _;
            throw new Error('Unexpected case.');
        }
    }
}
function mergeArraysUsingReaderAst(field, oldItems, newItems) {
    if (newItems.length !== oldItems.length) {
        return newItems;
    }
    let canRecycle = true;
    for (let i = 0; i < newItems.length; i++) {
        const mergedItem = mergeUsingReaderAst(field, oldItems[i], newItems[i]);
        if (mergedItem !== oldItems[i]) {
            canRecycle = false;
        }
        else {
            newItems[i] = mergedItem;
        }
    }
    return canRecycle ? oldItems : newItems;
}
function mergeObjectsUsingReaderAst(ast, oldItemObject, newItemObject) {
    var _a;
    let canRecycle = true;
    for (const field of ast) {
        switch (field.kind) {
            case 'Scalar':
            case 'Linked':
                if (field.kind === 'Linked' && field.refetchQueryIndex != null) {
                    // client pointers are functions, so we can't merge them
                    canRecycle = false;
                    break;
                }
                const key = (_a = field.alias) !== null && _a !== void 0 ? _a : field.fieldName;
                // @ts-expect-error
                const oldValue = oldItemObject[key];
                // @ts-expect-error
                const newValue = newItemObject[key];
                const mergedValue = mergeUsingReaderAst(field, oldValue, newValue);
                if (mergedValue !== oldValue) {
                    canRecycle = false;
                }
                else {
                    // @ts-expect-error
                    newItemObject[key] = mergedValue;
                }
                break;
            case 'Resolver': {
                const key = field.alias;
                // @ts-expect-error
                const oldValue = oldItemObject[key];
                // @ts-expect-error
                const newValue = newItemObject[key];
                if (oldValue !== newValue) {
                    canRecycle = false;
                }
                break;
            }
            case 'Link': {
                const key = field.alias;
                // @ts-expect-error
                const oldValue = oldItemObject[key];
                // @ts-expect-error
                const newValue = newItemObject[key];
                if (oldValue.__link !== newValue.__link ||
                    oldValue.__typename !== newValue.__typename) {
                    canRecycle = false;
                }
                else {
                    // @ts-expect-error
                    newItemObject[key] = oldValue;
                }
                break;
            }
            case 'ImperativelyLoadedField':
            case 'LoadablySelectedField':
                break;
            default: {
                // Ensure we have covered all variants
                let _ = field;
                _;
                throw new Error('Unexpected case.');
            }
        }
    }
    return canRecycle ? oldItemObject : newItemObject;
}
