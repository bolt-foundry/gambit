"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maybeMakeNetworkRequest = maybeMakeNetworkRequest;
exports.makeNetworkRequest = makeNetworkRequest;
const cache_1 = require("./cache");
const check_1 = require("./check");
const componentCache_1 = require("./componentCache");
const garbageCollection_1 = require("./garbageCollection");
const IsographEnvironment_1 = require("./IsographEnvironment");
const logging_1 = require("./logging");
const PromiseWrapper_1 = require("./PromiseWrapper");
const read_1 = require("./read");
const startUpdate_1 = require("./startUpdate");
let networkRequestId = 0;
function maybeMakeNetworkRequest(environment, artifact, variables, readerWithRefetchQueries, fetchOptions) {
    var _a;
    switch ((_a = fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.shouldFetch) !== null && _a !== void 0 ? _a : check_1.DEFAULT_SHOULD_FETCH_VALUE) {
        case 'Yes': {
            return makeNetworkRequest(environment, artifact, variables, readerWithRefetchQueries, fetchOptions);
        }
        case 'No': {
            return [(0, PromiseWrapper_1.wrapResolvedValue)(undefined), () => { }];
        }
        case 'IfNecessary': {
            if (artifact.networkRequestInfo.normalizationAst.kind ===
                'NormalizationAstLoader') {
                throw new Error('Using lazy loaded normalizationAst with shouldFetch: "IfNecessary" is not supported as it will lead to slower initial load time.');
            }
            const result = (0, check_1.check)(environment, artifact.networkRequestInfo.normalizationAst.selections, variables, {
                __link: IsographEnvironment_1.ROOT_ID,
                __typename: artifact.concreteType,
            });
            if (result.kind === 'EnoughData') {
                return [(0, PromiseWrapper_1.wrapResolvedValue)(undefined), () => { }];
            }
            else {
                return makeNetworkRequest(environment, artifact, variables, readerWithRefetchQueries, fetchOptions);
            }
        }
    }
}
function loadNormalizationAst(normalizationAst) {
    switch (normalizationAst.kind) {
        case 'NormalizationAst': {
            return normalizationAst;
        }
        case 'NormalizationAstLoader': {
            return normalizationAst.loader();
        }
    }
}
function makeNetworkRequest(environment, artifact, variables, readerWithRefetchQueries, fetchOptions) {
    // TODO this should be a DataId and stored in the store
    const myNetworkRequestId = networkRequestId + '';
    networkRequestId++;
    (0, logging_1.logMessage)(environment, () => ({
        kind: 'MakeNetworkRequest',
        artifact,
        variables,
        networkRequestId: myNetworkRequestId,
    }));
    let status = {
        kind: 'UndisposedIncomplete',
    };
    // This should be an observable, not a promise
    const promise = Promise.all([
        environment.networkFunction(artifact.networkRequestInfo.operation, variables),
        loadNormalizationAst(artifact.networkRequestInfo.normalizationAst),
        readerWithRefetchQueries === null || readerWithRefetchQueries === void 0 ? void 0 : readerWithRefetchQueries.promise,
    ])
        .then(([networkResponse, normalizationAst, readerWithRefetchQueries]) => {
        var _a, _b;
        (0, logging_1.logMessage)(environment, () => ({
            kind: 'ReceivedNetworkResponse',
            networkResponse,
            networkRequestId: myNetworkRequestId,
        }));
        if (networkResponse.errors != null) {
            try {
                (_a = fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.onError) === null || _a === void 0 ? void 0 : _a.call(fetchOptions);
            }
            catch (_c) { }
            throw new Error('GraphQL network response had errors', {
                cause: networkResponse,
            });
        }
        const root = { __link: IsographEnvironment_1.ROOT_ID, __typename: artifact.concreteType };
        if (status.kind === 'UndisposedIncomplete') {
            (0, cache_1.normalizeData)(environment, normalizationAst.selections, (_b = networkResponse.data) !== null && _b !== void 0 ? _b : {}, variables, root);
            const retainedQuery = {
                normalizationAst: normalizationAst.selections,
                variables,
                root,
            };
            status = {
                kind: 'UndisposedComplete',
                retainedQuery,
            };
            (0, garbageCollection_1.retainQuery)(environment, retainedQuery);
        }
        const onComplete = fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.onComplete;
        if (onComplete != null) {
            let data = readDataForOnComplete(artifact, environment, root, variables, readerWithRefetchQueries);
            try {
                // @ts-expect-error this problem will be fixed when we remove RefetchQueryNormalizationArtifact
                // (or we can fix this by having a single param of type { kind: 'Entrypoint', entrypoint,
                // fetchOptions: FetchOptions<TReadFromStore> } | { kind: 'RefetchQuery', refetchQuery,
                // fetchOptions: FetchOptions<void> }).
                onComplete(data);
            }
            catch (_d) { }
        }
    })
        .catch((e) => {
        var _a;
        (0, logging_1.logMessage)(environment, () => ({
            kind: 'ReceivedNetworkError',
            networkRequestId: myNetworkRequestId,
            error: e,
        }));
        try {
            (_a = fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.onError) === null || _a === void 0 ? void 0 : _a.call(fetchOptions);
        }
        catch (_b) { }
        throw e;
    });
    const wrapper = (0, PromiseWrapper_1.wrapPromise)(promise);
    const response = [
        wrapper,
        () => {
            if (status.kind === 'UndisposedComplete') {
                const didUnretainSomeQuery = (0, garbageCollection_1.unretainQuery)(environment, status.retainedQuery);
                if (didUnretainSomeQuery) {
                    (0, garbageCollection_1.garbageCollectEnvironment)(environment);
                }
            }
            status = {
                kind: 'Disposed',
            };
        },
    ];
    return response;
}
function readDataForOnComplete(artifact, environment, root, variables, readerWithRefetchQueries) {
    // An entrypoint, but not a RefetchQueryNormalizationArtifact, has a reader ASTs.
    // So, we can only pass data to onComplete if makeNetworkRequest was passed an entrypoint.
    // This is awkward, since we don't express that in the types of the parameters
    // (i.e. FetchOptions could be passed, along with a RefetchQueryNormalizationArtifact).
    //
    // However, this isn't a big deal: RefetchQueryNormalizationArtifact is going away.
    if (artifact.kind === 'Entrypoint') {
        // TODO this is a smell!
        const fakeNetworkRequest = (0, PromiseWrapper_1.wrapResolvedValue)(undefined);
        // TODO this is a smell â€” we know the network response is not in flight,
        // so we don't really care!
        const fakeNetworkRequestOptions = {
            suspendIfInFlight: false,
            throwOnNetworkError: false,
        };
        const resolvedReaderWithRefetchQueries = readerWithRefetchQueries;
        const fragment = {
            kind: 'FragmentReference',
            // TODO this smells.
            readerWithRefetchQueries: (0, PromiseWrapper_1.wrapResolvedValue)(resolvedReaderWithRefetchQueries),
            root,
            variables,
            networkRequest: fakeNetworkRequest,
        };
        const fragmentResult = (0, read_1.readButDoNotEvaluate)(environment, fragment, fakeNetworkRequestOptions).item;
        const readerArtifact = resolvedReaderWithRefetchQueries.readerArtifact;
        switch (readerArtifact.kind) {
            case 'ComponentReaderArtifact': {
                // @ts-expect-error We should find a way to encode this in the type system:
                // if we have a ComponentReaderArtifact, we will necessarily have a
                // TClientFieldValue which is a React.FC<...>
                return (0, componentCache_1.getOrCreateCachedComponent)(environment, readerArtifact.fieldName, {
                    kind: 'FragmentReference',
                    readerWithRefetchQueries: (0, PromiseWrapper_1.wrapResolvedValue)({
                        kind: 'ReaderWithRefetchQueries',
                        readerArtifact: readerArtifact,
                        nestedRefetchQueries: resolvedReaderWithRefetchQueries.nestedRefetchQueries,
                    }),
                    root,
                    variables,
                    networkRequest: fakeNetworkRequest,
                }, fakeNetworkRequestOptions);
            }
            case 'EagerReaderArtifact': {
                return readerArtifact.resolver(Object.assign({ data: fragmentResult, parameters: variables }, (readerArtifact.hasUpdatable
                    ? {
                        startUpdate: (0, startUpdate_1.getOrCreateCachedStartUpdate)(environment, fragment, resolvedReaderWithRefetchQueries.readerArtifact.fieldName, fakeNetworkRequestOptions),
                    }
                    : undefined)));
            }
            default: {
                const _ = readerArtifact;
                _;
                throw new Error('Expected case');
            }
        }
    }
    return null;
}
