import { ReaderWithRefetchQueries } from '../core/entrypoint';
import { type StoreLink } from './IsographEnvironment';
import { PromiseWrapper } from './PromiseWrapper';
import type { StartUpdate } from './reader';
export type VariableValue = string | number | boolean | null | {
    readonly [index: string]: VariableValue;
} | VariableValue[];
export type Variables = {
    readonly [index: string]: VariableValue;
};
export type UnknownTReadFromStore = {
    parameters: object;
    data: object;
    startUpdate?: StartUpdate<object>;
};
export type ExtractData<T> = T extends {
    data: infer D extends object;
} ? D : never;
export type ExtractParameters<T> = T extends {
    parameters: infer P extends Variables;
} ? P : Variables;
export type ExtractStartUpdate<T extends UnknownTReadFromStore> = T['startUpdate'];
export type ExtractUpdatableData<T extends UnknownTReadFromStore> = ExtractUpdatableDataFromStartUpdate<ExtractStartUpdate<T>>;
export type ExtractUpdatableDataFromStartUpdate<T> = T extends StartUpdate<infer D> ? D : never;
export type FragmentReference<TReadFromStore extends UnknownTReadFromStore, TClientFieldValue> = {
    readonly kind: 'FragmentReference';
    readonly readerWithRefetchQueries: PromiseWrapper<ReaderWithRefetchQueries<TReadFromStore, TClientFieldValue>>;
    readonly root: StoreLink;
    readonly variables: ExtractParameters<TReadFromStore>;
    readonly networkRequest: PromiseWrapper<void, any>;
};
export type StableIdForFragmentReference = string;
export declare function stableIdForFragmentReference(fragmentReference: FragmentReference<any, any>, fieldName: string): StableIdForFragmentReference;
//# sourceMappingURL=FragmentReference.d.ts.map