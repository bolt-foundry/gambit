import { Factory } from '@isograph/disposable-types';
import { FetchOptions } from './check';
import { IsographEntrypoint, IsographEntrypointLoader, RefetchQueryNormalizationArtifact, RefetchQueryNormalizationArtifactWrapper } from './entrypoint';
import { ExtractParameters, FragmentReference, type UnknownTReadFromStore } from './FragmentReference';
import { ComponentOrFieldName, IsographEnvironment, type StoreLink } from './IsographEnvironment';
import { Arguments } from './util';
export type TopLevelReaderArtifact<TReadFromStore extends UnknownTReadFromStore, TClientFieldValue, TComponentProps extends Record<PropertyKey, never>> = EagerReaderArtifact<TReadFromStore, TClientFieldValue> | ComponentReaderArtifact<TReadFromStore, TComponentProps>;
export type EagerReaderArtifact<TReadFromStore extends UnknownTReadFromStore, TClientFieldValue> = {
    readonly kind: 'EagerReaderArtifact';
    readonly fieldName: string;
    readonly readerAst: ReaderAst<TReadFromStore>;
    readonly resolver: (data: ResolverFirstParameter<TReadFromStore>) => TClientFieldValue;
    readonly hasUpdatable: boolean;
};
export type ComponentReaderArtifact<TReadFromStore extends UnknownTReadFromStore, TComponentProps extends Record<string, unknown> = Record<PropertyKey, never>> = {
    readonly kind: 'ComponentReaderArtifact';
    readonly fieldName: ComponentOrFieldName;
    readonly readerAst: ReaderAst<TReadFromStore>;
    readonly resolver: (data: ResolverFirstParameter<TReadFromStore>, runtimeProps: TComponentProps) => React.ReactNode;
    readonly hasUpdatable: boolean;
};
export type ResolverFirstParameter<TReadFromStore extends UnknownTReadFromStore> = Pick<TReadFromStore, 'data' | 'parameters' | 'startUpdate'>;
export type StartUpdate<UpdatableData> = (updater: (updatableData: UpdatableData) => void) => void;
export type RefetchReaderArtifact = {
    readonly kind: 'RefetchReaderArtifact';
    readonly readerAst: ReaderAst<unknown>;
    readonly resolver: (environment: IsographEnvironment, artifact: RefetchQueryNormalizationArtifact, variables: any, filteredVariables: any, rootLink: StoreLink, readerArtifact: TopLevelReaderArtifact<any, any, any> | null, nestedRefetchQueries: RefetchQueryNormalizationArtifactWrapper[]) => () => void;
};
export type ReaderAstNode = ReaderScalarField | ReaderLinkedField | ReaderNonLoadableResolverField | ReaderImperativelyLoadedField | LoadablySelectedField | ReaderLinkField;
export type ReaderAst<TReadFromStore> = ReadonlyArray<ReaderAstNode>;
export type ReaderScalarField = {
    readonly kind: 'Scalar';
    readonly fieldName: string;
    readonly alias: string | null;
    readonly arguments: Arguments | null;
    readonly isUpdatable: boolean;
};
export type ReaderLinkField = {
    readonly kind: 'Link';
    readonly alias: string;
};
export type ReaderLinkedField = {
    readonly kind: 'Linked';
    readonly fieldName: string;
    readonly alias: string | null;
    readonly selections: ReaderAst<unknown>;
    readonly arguments: Arguments | null;
    readonly condition: EagerReaderArtifact<{
        data: any;
        parameters: any;
        startUpdate?: StartUpdate<any>;
    }, StoreLink | null> | null;
    readonly isUpdatable: boolean;
    /**
     * If refetchQueryIndex != null, then the linked field is a client pointer.
     */
    readonly refetchQueryIndex: number | null;
};
export type ReaderNonLoadableResolverField = {
    readonly kind: 'Resolver';
    readonly alias: string;
    readonly readerArtifact: TopLevelReaderArtifact<any, any, any>;
    readonly arguments: Arguments | null;
    readonly usedRefetchQueries: number[];
};
export type ReaderImperativelyLoadedField = {
    readonly kind: 'ImperativelyLoadedField';
    readonly alias: string;
    readonly refetchReaderArtifact: RefetchReaderArtifact;
    readonly refetchQueryIndex: number;
    readonly name: string;
};
export type LoadablySelectedField = {
    readonly kind: 'LoadablySelectedField';
    readonly alias: string;
    readonly name: string;
    readonly queryArguments: Arguments | null;
    readonly refetchReaderAst: ReaderAst<any>;
    readonly entrypoint: IsographEntrypoint<any, any, any> | IsographEntrypointLoader<any, any>;
};
export type StableId = string;
export type LoadableField<TReadFromStore extends UnknownTReadFromStore, TResult, TArgs = ExtractParameters<TReadFromStore>> = (args: TArgs | void, fetchOptions: FetchOptions<TResult>) => [StableId, Factory<FragmentReference<TReadFromStore, TResult>>];
//# sourceMappingURL=reader.d.ts.map