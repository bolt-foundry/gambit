"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readButDoNotEvaluate = readButDoNotEvaluate;
exports.readLoadablySelectedFieldData = readLoadablySelectedFieldData;
exports.readResolverFieldData = readResolverFieldData;
exports.readScalarFieldData = readScalarFieldData;
exports.readLinkedFieldData = readLinkedFieldData;
exports.getNetworkRequestOptionsWithDefaults = getNetworkRequestOptionsWithDefaults;
exports.readImperativelyLoadedField = readImperativelyLoadedField;
const cache_1 = require("./cache");
const componentCache_1 = require("./componentCache");
const IsographEnvironment_1 = require("./IsographEnvironment");
const logging_1 = require("./logging");
const makeNetworkRequest_1 = require("./makeNetworkRequest");
const PromiseWrapper_1 = require("./PromiseWrapper");
const startUpdate_1 = require("./startUpdate");
function readButDoNotEvaluate(environment, fragmentReference, networkRequestOptions) {
    var _a;
    const mutableEncounteredRecords = new Map();
    // TODO consider moving this to the outside
    const readerWithRefetchQueries = (0, PromiseWrapper_1.readPromise)(fragmentReference.readerWithRefetchQueries);
    const response = readData(environment, readerWithRefetchQueries.readerArtifact.readerAst, fragmentReference.root, (_a = fragmentReference.variables) !== null && _a !== void 0 ? _a : {}, readerWithRefetchQueries.nestedRefetchQueries, fragmentReference.networkRequest, networkRequestOptions, mutableEncounteredRecords);
    (0, logging_1.logMessage)(environment, () => ({
        kind: 'DoneReading',
        response,
        fieldName: readerWithRefetchQueries.readerArtifact.fieldName,
        root: fragmentReference.root,
    }));
    if (response.kind === 'MissingData') {
        // There are two cases here that we care about:
        // 1. the network request is in flight, we haven't suspended on it, and we want
        //    to throw if it errors out. So, networkRequestOptions.suspendIfInFlight === false
        //    and networkRequestOptions.throwOnNetworkError === true.
        // 2. everything else
        //
        // In the first case, we cannot simply throw onNextChange, because if the network
        // response errors out, we will not update the store, so the onNextChange promise
        // will not resolve.
        if (!networkRequestOptions.suspendIfInFlight &&
            networkRequestOptions.throwOnNetworkError) {
            // What are we doing here? If the network response has errored out, we can do
            // two things: throw a rejected promise, or throw an error. Both work identically
            // in the browser. However, during initial SSR on NextJS, throwing a rejected
            // promise results in an infinite loop (including re-issuing the query until the
            // process OOM's or something.) Hence, we throw an error.
            const result = fragmentReference.networkRequest.result;
            if (result !== PromiseWrapper_1.NOT_SET && result.kind === 'Err') {
                throw new Error('NetworkError', { cause: result.error });
            }
            throw new Promise((resolve, reject) => {
                (0, cache_1.onNextChangeToRecord)(environment, response.recordLink).then(resolve);
                fragmentReference.networkRequest.promise.catch(reject);
            });
        }
        throw (0, cache_1.onNextChangeToRecord)(environment, response.recordLink);
    }
    else {
        return {
            encounteredRecords: mutableEncounteredRecords,
            item: response.data,
        };
    }
}
function readData(environment, ast, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, mutableEncounteredRecords) {
    var _a, _b, _c;
    const encounteredIds = (0, cache_1.insertEmptySetIfMissing)(mutableEncounteredRecords, root.__typename);
    encounteredIds.add(root.__link);
    let storeRecord = (_a = environment.store[root.__typename]) === null || _a === void 0 ? void 0 : _a[root.__link];
    if (storeRecord === undefined) {
        return {
            kind: 'MissingData',
            reason: 'No record for root ' + root.__link,
            recordLink: root,
        };
    }
    if (storeRecord === null) {
        return {
            kind: 'Success',
            data: null,
        };
    }
    let target = {};
    for (const field of ast) {
        switch (field.kind) {
            case 'Scalar': {
                const data = readScalarFieldData(field, storeRecord, root, variables);
                if (data.kind === 'MissingData') {
                    return data;
                }
                target[(_b = field.alias) !== null && _b !== void 0 ? _b : field.fieldName] = data.data;
                break;
            }
            case 'Link': {
                target[field.alias] = root;
                break;
            }
            case 'Linked': {
                const data = readLinkedFieldData(environment, field, storeRecord, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, (ast, root) => readData(environment, ast, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, mutableEncounteredRecords));
                if (data.kind === 'MissingData') {
                    return data;
                }
                target[(_c = field.alias) !== null && _c !== void 0 ? _c : field.fieldName] = data.data;
                break;
            }
            case 'ImperativelyLoadedField': {
                const data = readImperativelyLoadedField(environment, field, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, mutableEncounteredRecords);
                if (data.kind === 'MissingData') {
                    return data;
                }
                target[field.alias] = data.data;
                break;
            }
            case 'Resolver': {
                const data = readResolverFieldData(environment, field, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, mutableEncounteredRecords);
                if (data.kind === 'MissingData') {
                    return data;
                }
                target[field.alias] = data.data;
                break;
            }
            case 'LoadablySelectedField': {
                const data = readLoadablySelectedFieldData(environment, field, root, variables, networkRequest, networkRequestOptions, mutableEncounteredRecords);
                if (data.kind === 'MissingData') {
                    return data;
                }
                target[field.alias] = data.data;
                break;
            }
            default: {
                // Ensure we have covered all variants
                let _ = field;
                _;
                throw new Error('Unexpected case.');
            }
        }
    }
    return {
        kind: 'Success',
        data: target,
    };
}
function readLoadablySelectedFieldData(environment, field, root, variables, networkRequest, networkRequestOptions, mutableEncounteredRecords) {
    const refetchReaderParams = readData(environment, field.refetchReaderAst, root, variables, 
    // Refetch fields just read the id, and don't need refetch query artifacts
    [], networkRequest, networkRequestOptions, mutableEncounteredRecords);
    if (refetchReaderParams.kind === 'MissingData') {
        return {
            kind: 'MissingData',
            reason: 'Missing data for ' + field.alias + ' on root ' + root.__link,
            nestedReason: refetchReaderParams,
            recordLink: refetchReaderParams.recordLink,
        };
    }
    return {
        kind: 'Success',
        data: (args, 
        // TODO get the associated type for FetchOptions from the loadably selected field
        fetchOptions) => {
            // TODO we should use the reader AST for this
            const includeReadOutData = (variables, readOutData) => {
                variables.id = readOutData.id;
                return variables;
            };
            const localVariables = includeReadOutData(args !== null && args !== void 0 ? args : {}, refetchReaderParams.data);
            writeQueryArgsToVariables(localVariables, field.queryArguments, variables);
            return [
                // Stable id
                root.__typename +
                    ':' +
                    root.__link +
                    '/' +
                    field.name +
                    '/' +
                    stableStringifyArgs(localVariables),
                // Fetcher
                () => {
                    const fragmentReferenceAndDisposeFromEntrypoint = (entrypoint) => {
                        const readerWithRefetchQueries = entrypoint.readerWithRefetchQueries.kind ===
                            'ReaderWithRefetchQueriesLoader'
                            ? (0, PromiseWrapper_1.wrapPromise)(entrypoint.readerWithRefetchQueries.loader())
                            : (0, PromiseWrapper_1.wrapResolvedValue)(entrypoint.readerWithRefetchQueries);
                        const [networkRequest, disposeNetworkRequest] = (0, makeNetworkRequest_1.maybeMakeNetworkRequest)(environment, entrypoint, localVariables, readerWithRefetchQueries, fetchOptions !== null && fetchOptions !== void 0 ? fetchOptions : null);
                        const fragmentReference = {
                            kind: 'FragmentReference',
                            readerWithRefetchQueries,
                            // TODO localVariables is not guaranteed to have an id field
                            root,
                            variables: localVariables,
                            networkRequest,
                        };
                        return [fragmentReference, disposeNetworkRequest];
                    };
                    if (field.entrypoint.kind === 'Entrypoint') {
                        return fragmentReferenceAndDisposeFromEntrypoint(field.entrypoint);
                    }
                    else {
                        const isographArtifactPromiseWrapper = (0, IsographEnvironment_1.getOrLoadIsographArtifact)(environment, field.entrypoint.typeAndField, field.entrypoint.loader);
                        const state = (0, PromiseWrapper_1.getPromiseState)(isographArtifactPromiseWrapper);
                        if (state.kind === 'Ok') {
                            return fragmentReferenceAndDisposeFromEntrypoint(state.value);
                        }
                        else {
                            // Promise is pending or thrown
                            let entrypointLoaderState = { kind: 'EntrypointNotLoaded' };
                            const readerWithRefetchQueries = (0, PromiseWrapper_1.wrapPromise)(isographArtifactPromiseWrapper.promise.then((entrypoint) => entrypoint.readerWithRefetchQueries.kind ===
                                'ReaderWithRefetchQueriesLoader'
                                ? entrypoint.readerWithRefetchQueries.loader()
                                : entrypoint.readerWithRefetchQueries));
                            const networkRequest = (0, PromiseWrapper_1.wrapPromise)(isographArtifactPromiseWrapper.promise.then((entrypoint) => {
                                if (entrypointLoaderState.kind === 'EntrypointNotLoaded') {
                                    const [networkRequest, disposeNetworkRequest] = (0, makeNetworkRequest_1.maybeMakeNetworkRequest)(environment, entrypoint, localVariables, readerWithRefetchQueries, fetchOptions !== null && fetchOptions !== void 0 ? fetchOptions : null);
                                    entrypointLoaderState = {
                                        kind: 'NetworkRequestStarted',
                                        disposeNetworkRequest,
                                    };
                                    return networkRequest.promise;
                                }
                            }));
                            const fragmentReference = {
                                kind: 'FragmentReference',
                                readerWithRefetchQueries,
                                // TODO localVariables is not guaranteed to have an id field
                                root,
                                variables: localVariables,
                                networkRequest,
                            };
                            return [
                                fragmentReference,
                                () => {
                                    if (entrypointLoaderState.kind === 'NetworkRequestStarted') {
                                        entrypointLoaderState.disposeNetworkRequest();
                                    }
                                    entrypointLoaderState = { kind: 'Disposed' };
                                },
                            ];
                        }
                    }
                },
            ];
        },
    };
}
function filterVariables(variables, allowedVariables) {
    const result = {};
    for (const key of allowedVariables) {
        // @ts-expect-error
        result[key] = variables[key];
    }
    return result;
}
function generateChildVariableMap(variables, fieldArguments) {
    if (fieldArguments == null) {
        return {};
    }
    const childVars = {};
    for (const [name, value] of fieldArguments) {
        if (value.kind === 'Object') {
            childVars[name] = generateChildVariableMap(variables, value.value);
        }
        else if (value.kind === 'Variable') {
            const variable = variables[value.name];
            // Variable could be null if it was not provided but has a default case,
            // so we allow the loop to continue rather than throwing an error.
            if (variable != null) {
                childVars[name] = variable;
            }
        }
        else {
            childVars[name] = value.value;
        }
    }
    return childVars;
}
function writeQueryArgsToVariables(targetVariables, queryArgs, variables) {
    if (queryArgs == null) {
        return;
    }
    for (const [name, argType] of queryArgs) {
        switch (argType.kind) {
            case 'Object': {
                writeQueryArgsToVariables((targetVariables[name] = {}), argType.value, variables);
                break;
            }
            case 'Variable': {
                targetVariables[name] = variables[argType.name];
                break;
            }
            case 'Enum': {
                targetVariables[name] = argType.value;
                break;
            }
            case 'Literal': {
                targetVariables[name] = argType.value;
                break;
            }
            case 'String': {
                targetVariables[name] = argType.value;
                break;
            }
            default: {
                const _ = argType;
                _;
                throw new Error('Unexpected case');
            }
        }
    }
}
function readResolverFieldData(environment, field, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, mutableEncounteredRecords) {
    const usedRefetchQueries = field.usedRefetchQueries;
    const resolverRefetchQueries = usedRefetchQueries.map((index) => {
        const resolverRefetchQuery = nestedRefetchQueries[index];
        if (resolverRefetchQuery == null) {
            throw new Error('resolverRefetchQuery is null in Resolver. This is indicative of a bug in Isograph.');
        }
        return resolverRefetchQuery;
    });
    const readerWithRefetchQueries = {
        kind: 'ReaderWithRefetchQueries',
        readerArtifact: field.readerArtifact,
        nestedRefetchQueries: resolverRefetchQueries,
    };
    const fragment = {
        kind: 'FragmentReference',
        readerWithRefetchQueries: (0, PromiseWrapper_1.wrapResolvedValue)(readerWithRefetchQueries),
        root,
        variables: generateChildVariableMap(variables, field.arguments),
        networkRequest,
    };
    switch (field.readerArtifact.kind) {
        case 'EagerReaderArtifact': {
            const data = readData(environment, field.readerArtifact.readerAst, root, generateChildVariableMap(variables, field.arguments), resolverRefetchQueries, networkRequest, networkRequestOptions, mutableEncounteredRecords);
            if (data.kind === 'MissingData') {
                return {
                    kind: 'MissingData',
                    reason: 'Missing data for ' + field.alias + ' on root ' + root.__link,
                    nestedReason: data,
                    recordLink: data.recordLink,
                };
            }
            const firstParameter = {
                data: data.data,
                parameters: variables,
                startUpdate: field.readerArtifact.hasUpdatable
                    ? (0, startUpdate_1.getOrCreateCachedStartUpdate)(environment, fragment, readerWithRefetchQueries.readerArtifact.fieldName, networkRequestOptions)
                    : undefined,
            };
            return {
                kind: 'Success',
                data: field.readerArtifact.resolver(firstParameter),
            };
        }
        case 'ComponentReaderArtifact': {
            return {
                kind: 'Success',
                data: (0, componentCache_1.getOrCreateCachedComponent)(environment, field.readerArtifact.fieldName, fragment, networkRequestOptions),
            };
        }
        default: {
            let _ = field.readerArtifact;
            _;
            throw new Error('Unexpected kind');
        }
    }
}
function readScalarFieldData(field, storeRecord, root, variables) {
    const storeRecordName = (0, cache_1.getParentRecordKey)(field, variables);
    const value = storeRecord[storeRecordName];
    // TODO consider making scalars into discriminated unions. This probably has
    // to happen for when we handle errors.
    if (value === undefined) {
        return {
            kind: 'MissingData',
            reason: 'No value for ' + storeRecordName + ' on root ' + root.__link,
            recordLink: root,
        };
    }
    return { kind: 'Success', data: value };
}
function readLinkedFieldData(environment, field, storeRecord, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, readData) {
    const storeRecordName = (0, cache_1.getParentRecordKey)(field, variables);
    const value = storeRecord[storeRecordName];
    if (Array.isArray(value)) {
        const results = [];
        for (const item of value) {
            const link = (0, IsographEnvironment_1.assertLink)(item);
            if (link === undefined) {
                return {
                    kind: 'MissingData',
                    reason: 'No link for ' +
                        storeRecordName +
                        ' on root ' +
                        root.__link +
                        '. Link is ' +
                        JSON.stringify(item),
                    recordLink: root,
                };
            }
            else if (link === null) {
                results.push(null);
                continue;
            }
            const result = readData(field.selections, link);
            if (result.kind === 'MissingData') {
                return {
                    kind: 'MissingData',
                    reason: 'Missing data for ' +
                        storeRecordName +
                        ' on root ' +
                        root.__link +
                        '. Link is ' +
                        JSON.stringify(item),
                    nestedReason: result,
                    recordLink: result.recordLink,
                };
            }
            results.push(result.data);
        }
        return {
            kind: 'Success',
            data: results,
        };
    }
    let link = (0, IsographEnvironment_1.assertLink)(value);
    if (field.condition) {
        const data = readData(field.condition.readerAst, root);
        if (data.kind === 'MissingData') {
            return {
                kind: 'MissingData',
                reason: 'Missing data for ' + storeRecordName + ' on root ' + root.__link,
                nestedReason: data,
                recordLink: data.recordLink,
            };
        }
        const readerWithRefetchQueries = {
            kind: 'ReaderWithRefetchQueries',
            readerArtifact: field.condition,
            // TODO this is wrong
            // should map field.condition.usedRefetchQueries
            // but it doesn't exist
            nestedRefetchQueries: [],
        };
        const fragment = {
            kind: 'FragmentReference',
            readerWithRefetchQueries: (0, PromiseWrapper_1.wrapResolvedValue)(readerWithRefetchQueries),
            root,
            variables: generateChildVariableMap(variables, 
            // TODO this is wrong
            // should use field.arguments
            // but it doesn't exist
            []),
            networkRequest,
        };
        const condition = field.condition.resolver(Object.assign({ data: data.data, parameters: {} }, (field.condition.hasUpdatable
            ? {
                startUpdate: (0, startUpdate_1.getOrCreateCachedStartUpdate)(environment, fragment, readerWithRefetchQueries.readerArtifact.fieldName, networkRequestOptions),
            }
            : undefined)));
        link = condition;
    }
    if (link === undefined) {
        // TODO make this configurable, and also generated and derived from the schema
        const missingFieldHandler = environment.missingFieldHandler;
        const altLink = missingFieldHandler === null || missingFieldHandler === void 0 ? void 0 : missingFieldHandler(storeRecord, root, field.fieldName, field.arguments, variables);
        (0, logging_1.logMessage)(environment, () => ({
            kind: 'MissingFieldHandlerCalled',
            root,
            storeRecord,
            fieldName: field.fieldName,
            arguments: field.arguments,
            variables,
        }));
        if (altLink === undefined) {
            return {
                kind: 'MissingData',
                reason: 'No link for ' +
                    storeRecordName +
                    ' on root ' +
                    root.__link +
                    '. Link is ' +
                    JSON.stringify(value),
                recordLink: root,
            };
        }
        else {
            link = altLink;
        }
    }
    else if (link === null) {
        return {
            kind: 'Success',
            data: null,
        };
    }
    const targetId = link;
    const { refetchQueryIndex } = field;
    if (refetchQueryIndex != null) {
        // if field.refetchQueryIndex is not null, then the field is a client pointer, i.e.
        // it is like a loadable field that returns the selections.
        const refetchReaderParams = readData([
            {
                kind: 'Scalar',
                fieldName: 'id',
                alias: null,
                arguments: null,
                isUpdatable: false,
            },
        ], targetId);
        if (refetchReaderParams.kind === 'MissingData') {
            return {
                kind: 'MissingData',
                reason: 'Missing data for ' + field.alias + ' on root ' + targetId.__link,
                nestedReason: refetchReaderParams,
                recordLink: refetchReaderParams.recordLink,
            };
        }
        const refetchQuery = nestedRefetchQueries[refetchQueryIndex];
        if (refetchQuery == null) {
            throw new Error('refetchQuery is null in RefetchField. This is indicative of a bug in Isograph.');
        }
        const refetchQueryArtifact = refetchQuery.artifact;
        const allowedVariables = refetchQuery.allowedVariables;
        return {
            kind: 'Success',
            data: (args, 
            // TODO get the associated type for FetchOptions from the loadably selected field
            fetchOptions) => {
                const includeReadOutData = (variables, readOutData) => {
                    variables.id = readOutData.id;
                    return variables;
                };
                const localVariables = includeReadOutData(args !== null && args !== void 0 ? args : {}, refetchReaderParams.data);
                writeQueryArgsToVariables(localVariables, field.arguments, variables);
                return [
                    // Stable id
                    targetId.__typename +
                        ':' +
                        targetId.__link +
                        '/' +
                        field.fieldName +
                        '/' +
                        stableStringifyArgs(localVariables),
                    // Fetcher
                    () => {
                        const variables = includeReadOutData(filterVariables(Object.assign(Object.assign({}, args), localVariables), allowedVariables), refetchReaderParams.data);
                        const readerWithRefetchQueries = (0, PromiseWrapper_1.wrapResolvedValue)({
                            kind: 'ReaderWithRefetchQueries',
                            readerArtifact: {
                                kind: 'EagerReaderArtifact',
                                fieldName: field.fieldName,
                                readerAst: field.selections,
                                resolver: ({ data }) => data,
                                hasUpdatable: false,
                            },
                            nestedRefetchQueries,
                        });
                        const [networkRequest, disposeNetworkRequest] = (0, makeNetworkRequest_1.maybeMakeNetworkRequest)(environment, refetchQueryArtifact, variables, readerWithRefetchQueries, fetchOptions !== null && fetchOptions !== void 0 ? fetchOptions : null);
                        const fragmentReference = {
                            kind: 'FragmentReference',
                            readerWithRefetchQueries: readerWithRefetchQueries,
                            root: targetId,
                            variables,
                            networkRequest,
                        };
                        return [fragmentReference, disposeNetworkRequest];
                    },
                ];
            },
        };
    }
    const data = readData(field.selections, targetId);
    if (data.kind === 'MissingData') {
        return {
            kind: 'MissingData',
            reason: 'Missing data for ' + storeRecordName + ' on root ' + root.__link,
            nestedReason: data,
            recordLink: data.recordLink,
        };
    }
    return data;
}
function getNetworkRequestOptionsWithDefaults(networkRequestOptions) {
    var _a, _b;
    return {
        suspendIfInFlight: (_a = networkRequestOptions === null || networkRequestOptions === void 0 ? void 0 : networkRequestOptions.suspendIfInFlight) !== null && _a !== void 0 ? _a : false,
        throwOnNetworkError: (_b = networkRequestOptions === null || networkRequestOptions === void 0 ? void 0 : networkRequestOptions.throwOnNetworkError) !== null && _b !== void 0 ? _b : true,
    };
}
// TODO use a description of the params for this?
// TODO call stableStringifyArgs on the variable values, as well.
// This doesn't matter for now, since we are just using primitive values
// in the demo.
function stableStringifyArgs(args) {
    const keys = Object.keys(args);
    keys.sort();
    let s = '';
    for (const key of keys) {
        // @ts-expect-error
        s += `${key}=${JSON.stringify(args[key])};`;
    }
    return s;
}
function readImperativelyLoadedField(environment, field, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, mutableEncounteredRecords) {
    // First, we read the data using the refetch reader AST (i.e. read out the
    // id field).
    const data = readData(environment, field.refetchReaderArtifact.readerAst, root, variables, 
    // Refetch fields just read the id, and don't need refetch query artifacts
    [], 
    // This is probably indicative of the fact that we are doing redundant checks
    // on the status of this network request...
    networkRequest, networkRequestOptions, mutableEncounteredRecords);
    if (data.kind === 'MissingData') {
        return {
            kind: 'MissingData',
            reason: 'Missing data for ' + field.alias + ' on root ' + root.__link,
            nestedReason: data,
            recordLink: data.recordLink,
        };
    }
    else {
        const { refetchQueryIndex } = field;
        const refetchQuery = nestedRefetchQueries[refetchQueryIndex];
        if (refetchQuery == null) {
            throw new Error('Refetch query not found. This is indicative of a bug in Isograph.');
        }
        const refetchQueryArtifact = refetchQuery.artifact;
        const allowedVariables = refetchQuery.allowedVariables;
        // Second, we allow the user to call the resolver, which will ultimately
        // use the resolver reader AST to get the resolver parameters.
        return {
            kind: 'Success',
            data: (args) => [
                // Stable id
                root.__typename + ':' + root.__link + '__' + field.name,
                // Fetcher
                field.refetchReaderArtifact.resolver(environment, refetchQueryArtifact, data.data, filterVariables(Object.assign(Object.assign({}, args), variables), allowedVariables), root, 
                // TODO these params should be removed
                null, []),
            ],
        };
    }
}
