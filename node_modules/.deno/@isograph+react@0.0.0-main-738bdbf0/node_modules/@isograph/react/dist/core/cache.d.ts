import { Factory, ParentCache } from '@isograph/react-disposable-state';
import { IsographEntrypoint, NormalizationLinkedField, NormalizationScalarField, type NormalizationAst, type NormalizationAstLoader, type NormalizationAstNodes } from '../core/entrypoint';
import { FetchOptions } from './check';
import { ExtractParameters, FragmentReference, Variables, type UnknownTReadFromStore } from './FragmentReference';
import { DataId, StoreLink, type IsographEnvironment, type TypeName } from './IsographEnvironment';
import { WithEncounteredRecords } from './read';
import { ReaderLinkedField, ReaderScalarField, type ReaderAst } from './reader';
export declare const TYPENAME_FIELD_NAME = "__typename";
export declare function getOrCreateItemInSuspenseCache<TReadFromStore extends UnknownTReadFromStore, TClientFieldValue>(environment: IsographEnvironment, index: string, factory: Factory<FragmentReference<TReadFromStore, TClientFieldValue>>): ParentCache<FragmentReference<TReadFromStore, TClientFieldValue>>;
/**
 * Creates a copy of the provided value, ensuring any nested objects have their
 * keys sorted such that equivalent values would have identical JSON.stringify
 * results.
 */
export declare function stableCopy<T>(value: T): T;
export declare function getOrCreateCacheForArtifact<TReadFromStore extends UnknownTReadFromStore, TClientFieldValue, TNormalizationAst extends NormalizationAst | NormalizationAstLoader>(environment: IsographEnvironment, entrypoint: IsographEntrypoint<TReadFromStore, TClientFieldValue, TNormalizationAst>, variables: ExtractParameters<TReadFromStore>, fetchOptions?: FetchOptions<TClientFieldValue>): ParentCache<FragmentReference<TReadFromStore, TClientFieldValue>>;
export type NetworkResponseScalarValue = string | number | boolean;
export type NetworkResponseValue = NetworkResponseScalarValue | null | NetworkResponseObject | (NetworkResponseObject | null)[] | (NetworkResponseScalarValue | null)[];
export type NetworkResponseObject = {
    [index: string]: undefined | NetworkResponseValue;
    id?: DataId;
    __typename?: TypeName;
};
export declare function normalizeData(environment: IsographEnvironment, normalizationAst: NormalizationAstNodes, networkResponse: NetworkResponseObject, variables: Variables, root: StoreLink): EncounteredIds;
export declare function subscribeToAnyChange(environment: IsographEnvironment, callback: () => void): () => void;
export declare function subscribeToAnyChangesToRecord(environment: IsographEnvironment, recordLink: StoreLink, callback: () => void): () => void;
export declare function subscribe<TReadFromStore extends UnknownTReadFromStore>(environment: IsographEnvironment, encounteredDataAndRecords: WithEncounteredRecords<TReadFromStore>, fragmentReference: FragmentReference<TReadFromStore, any>, callback: (newEncounteredDataAndRecords: WithEncounteredRecords<TReadFromStore>) => void, readerAst: ReaderAst<TReadFromStore>): () => void;
export declare function onNextChangeToRecord(environment: IsographEnvironment, recordLink: StoreLink): Promise<void>;
export declare function callSubscriptions(environment: IsographEnvironment, recordsEncounteredWhenNormalizing: EncounteredIds): void;
export type EncounteredIds = Map<TypeName, Set<DataId>>;
export declare function insertEmptySetIfMissing<K, V>(map: Map<K, Set<V>>, key: K): Set<V>;
export declare function getParentRecordKey(astNode: NormalizationLinkedField | NormalizationScalarField | ReaderLinkedField | ReaderScalarField, variables: Variables): string;
export declare const FIRST_SPLIT_KEY = "____";
export declare const SECOND_SPLIT_KEY = "___";
export declare const THIRD_SPLIT_KEY = "__";
//# sourceMappingURL=cache.d.ts.map