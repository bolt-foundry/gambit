export type AnyError = any;
export declare const NOT_SET: unique symbol;
export type NotSet = typeof NOT_SET;
export type Result<T, E> = {
    kind: 'Ok';
    value: T;
} | {
    kind: 'Err';
    error: E;
};
/**
 * Invariant:
 * Before the promise is resolved, value becomes non-null.
 */
export type PromiseWrapper<T, E = any> = {
    readonly promise: Promise<Exclude<T, NotSet>>;
    result: Result<Exclude<T, NotSet>, E> | NotSet;
};
export declare function wrapPromise<T>(promise: Promise<Exclude<T, NotSet>>): PromiseWrapper<T, unknown>;
export declare function wrapResolvedValue<T>(value: Exclude<T, NotSet>): PromiseWrapper<T, never>;
export declare function readPromise<T, E>(p: PromiseWrapper<T, E>): T;
export type PromiseState<T, E> = {
    kind: 'Pending';
    promise: Promise<T>;
} | Result<T, E>;
export declare function getPromiseState<T, E>(p: PromiseWrapper<T, E>): PromiseState<T, E>;
//# sourceMappingURL=PromiseWrapper.d.ts.map