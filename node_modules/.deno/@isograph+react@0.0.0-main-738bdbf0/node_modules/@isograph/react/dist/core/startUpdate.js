"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrCreateCachedStartUpdate = getOrCreateCachedStartUpdate;
exports.createStartUpdate = createStartUpdate;
exports.createUpdatableProxy = createUpdatableProxy;
const cache_1 = require("./cache");
const FragmentReference_1 = require("./FragmentReference");
const IsographEnvironment_1 = require("./IsographEnvironment");
const logging_1 = require("./logging");
const PromiseWrapper_1 = require("./PromiseWrapper");
const read_1 = require("./read");
function getOrCreateCachedStartUpdate(environment, fragmentReference, eagerResolverName, networkRequestOptions) {
    var _a;
    var _b, _c;
    return ((_a = (_b = environment.eagerReaderCache)[_c = (0, FragmentReference_1.stableIdForFragmentReference)(fragmentReference, eagerResolverName)]) !== null && _a !== void 0 ? _a : (_b[_c] = createStartUpdate(environment, fragmentReference, networkRequestOptions)));
}
function createStartUpdate(environment, fragmentReference, networkRequestOptions) {
    return (updater) => {
        let mutableUpdatedIds = new Map();
        let data = createUpdatableProxy(environment, fragmentReference, networkRequestOptions, mutableUpdatedIds);
        try {
            updater(data);
        }
        catch (e) {
            (0, logging_1.logMessage)(environment, () => ({
                kind: 'StartUpdateError',
                error: e,
            }));
            throw e;
        }
        finally {
            (0, logging_1.logMessage)(environment, () => ({
                kind: 'StartUpdateComplete',
                updatedIds: mutableUpdatedIds,
            }));
            (0, cache_1.callSubscriptions)(environment, mutableUpdatedIds);
        }
    };
}
function createUpdatableProxy(environment, fragmentReference, networkRequestOptions, mutableUpdatedIds) {
    var _a;
    const readerWithRefetchQueries = (0, PromiseWrapper_1.readPromise)(fragmentReference.readerWithRefetchQueries);
    return readUpdatableData(environment, readerWithRefetchQueries.readerArtifact.readerAst, fragmentReference.root, (_a = fragmentReference.variables) !== null && _a !== void 0 ? _a : {}, readerWithRefetchQueries.nestedRefetchQueries, fragmentReference.networkRequest, networkRequestOptions, {
        lastInvalidated: 0,
    }, mutableUpdatedIds).data;
}
function defineCachedProperty(target, property, mutableState, get, set) {
    let value = {
        kind: 'NotSet',
    };
    Object.defineProperty(target, property, Object.assign({ configurable: false, enumerable: true, get: () => {
            if (value.kind === 'NotSet' ||
                value.validatedAt < mutableState.lastInvalidated) {
                value = {
                    kind: 'Set',
                    value: get(),
                    validatedAt: mutableState.lastInvalidated,
                };
            }
            return value.value;
        } }, (set && {
        set: (newValue) => {
            set(newValue);
            mutableState.lastInvalidated++;
        },
    })));
}
function readUpdatableData(environment, ast, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, mutableState, mutableUpdatedIds) {
    var _a, _b, _c;
    let storeRecord = (_a = environment.store[root.__typename]) === null || _a === void 0 ? void 0 : _a[root.__link];
    if (storeRecord == null) {
        return {
            kind: 'Success',
            data: null,
        };
    }
    let target = {};
    for (const field of ast) {
        switch (field.kind) {
            case 'Scalar': {
                const storeRecordName = (0, cache_1.getParentRecordKey)(field, variables);
                defineCachedProperty(target, (_b = field.alias) !== null && _b !== void 0 ? _b : field.fieldName, mutableState, () => {
                    const data = (0, read_1.readScalarFieldData)(field, storeRecord, root, variables);
                    if (data.kind === 'MissingData') {
                        throw new Error(data.reason);
                    }
                    return data.data;
                }, field.isUpdatable
                    ? (newValue) => {
                        storeRecord[storeRecordName] = newValue;
                        const updatedIds = (0, cache_1.insertEmptySetIfMissing)(mutableUpdatedIds, root.__typename);
                        updatedIds.add(root.__link);
                    }
                    : undefined);
                break;
            }
            case 'Linked': {
                const storeRecordName = (0, cache_1.getParentRecordKey)(field, variables);
                defineCachedProperty(target, (_c = field.alias) !== null && _c !== void 0 ? _c : field.fieldName, mutableState, () => {
                    const data = (0, read_1.readLinkedFieldData)(environment, field, storeRecord, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, (ast, root) => readUpdatableData(environment, ast, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, mutableState, mutableUpdatedIds));
                    if (data.kind === 'MissingData') {
                        throw new Error(data.reason);
                    }
                    return data.data;
                }, 'isUpdatable' in field && field.isUpdatable
                    ? (newValue) => {
                        if (Array.isArray(newValue)) {
                            storeRecord[storeRecordName] = newValue.map((node) => (0, IsographEnvironment_1.assertLink)(node === null || node === void 0 ? void 0 : node.__link));
                        }
                        else {
                            storeRecord[storeRecordName] = (0, IsographEnvironment_1.assertLink)(newValue === null || newValue === void 0 ? void 0 : newValue.__link);
                        }
                        const updatedIds = (0, cache_1.insertEmptySetIfMissing)(mutableUpdatedIds, root.__typename);
                        updatedIds.add(root.__link);
                    }
                    : undefined);
                break;
            }
            case 'ImperativelyLoadedField': {
                defineCachedProperty(target, field.alias, mutableState, () => {
                    const data = (0, read_1.readImperativelyLoadedField)(environment, field, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, new Map());
                    if (data.kind === 'MissingData') {
                        throw new Error(data.reason);
                    }
                    return data.data;
                });
                break;
            }
            case 'Resolver': {
                defineCachedProperty(target, field.alias, mutableState, () => {
                    const data = (0, read_1.readResolverFieldData)(environment, field, root, variables, nestedRefetchQueries, networkRequest, networkRequestOptions, new Map());
                    if (data.kind === 'MissingData') {
                        throw new Error(data.reason);
                    }
                    return data.data;
                });
                break;
            }
            case 'LoadablySelectedField': {
                defineCachedProperty(target, field.alias, mutableState, () => {
                    const data = (0, read_1.readLoadablySelectedFieldData)(environment, field, root, variables, networkRequest, networkRequestOptions, new Map());
                    if (data.kind === 'MissingData') {
                        throw new Error(data.reason);
                    }
                    return data.data;
                });
                break;
            }
            case 'Link': {
                target[field.alias] = root;
                break;
            }
            default: {
                field;
                throw new Error('Unexpected case.');
            }
        }
    }
    return {
        kind: 'Success',
        data: target,
    };
}
