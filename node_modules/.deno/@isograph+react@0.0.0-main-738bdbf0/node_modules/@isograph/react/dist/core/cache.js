"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.THIRD_SPLIT_KEY = exports.SECOND_SPLIT_KEY = exports.FIRST_SPLIT_KEY = exports.TYPENAME_FIELD_NAME = void 0;
exports.getOrCreateItemInSuspenseCache = getOrCreateItemInSuspenseCache;
exports.stableCopy = stableCopy;
exports.getOrCreateCacheForArtifact = getOrCreateCacheForArtifact;
exports.normalizeData = normalizeData;
exports.subscribeToAnyChange = subscribeToAnyChange;
exports.subscribeToAnyChangesToRecord = subscribeToAnyChangesToRecord;
exports.subscribe = subscribe;
exports.onNextChangeToRecord = onNextChangeToRecord;
exports.callSubscriptions = callSubscriptions;
exports.insertEmptySetIfMissing = insertEmptySetIfMissing;
exports.getParentRecordKey = getParentRecordKey;
const react_disposable_state_1 = require("@isograph/react-disposable-state");
const areEqualWithDeepComparison_1 = require("./areEqualWithDeepComparison");
const IsographEnvironment_1 = require("./IsographEnvironment");
const logging_1 = require("./logging");
const makeNetworkRequest_1 = require("./makeNetworkRequest");
const PromiseWrapper_1 = require("./PromiseWrapper");
const read_1 = require("./read");
exports.TYPENAME_FIELD_NAME = '__typename';
function getOrCreateItemInSuspenseCache(environment, index, factory) {
    if (environment.fragmentCache[index] == null) {
        environment.fragmentCache[index] = new react_disposable_state_1.ParentCache(factory);
    }
    return environment.fragmentCache[index];
}
/**
 * Creates a copy of the provided value, ensuring any nested objects have their
 * keys sorted such that equivalent values would have identical JSON.stringify
 * results.
 */
function stableCopy(value) {
    if (!value || typeof value !== 'object') {
        return value;
    }
    if (Array.isArray(value)) {
        // @ts-ignore
        return value.map(stableCopy);
    }
    const keys = Object.keys(value).sort();
    const stable = {};
    for (let i = 0; i < keys.length; i++) {
        // @ts-ignore
        stable[keys[i]] = stableCopy(value[keys[i]]);
    }
    return stable;
}
function getOrCreateCacheForArtifact(environment, entrypoint, variables, fetchOptions) {
    let cacheKey = '';
    switch (entrypoint.networkRequestInfo.operation.kind) {
        case 'Operation':
            cacheKey =
                entrypoint.networkRequestInfo.operation.text +
                    JSON.stringify(stableCopy(variables));
            break;
        case 'PersistedOperation':
            cacheKey =
                entrypoint.networkRequestInfo.operation.operationId +
                    JSON.stringify(stableCopy(variables));
            break;
    }
    const factory = () => {
        const readerWithRefetchQueries = entrypoint.readerWithRefetchQueries.kind ===
            'ReaderWithRefetchQueriesLoader'
            ? (0, PromiseWrapper_1.wrapPromise)(entrypoint.readerWithRefetchQueries.loader())
            : (0, PromiseWrapper_1.wrapResolvedValue)(entrypoint.readerWithRefetchQueries);
        const [networkRequest, disposeNetworkRequest] = (0, makeNetworkRequest_1.maybeMakeNetworkRequest)(environment, entrypoint, variables, readerWithRefetchQueries, fetchOptions !== null && fetchOptions !== void 0 ? fetchOptions : null);
        const itemCleanupPair = [
            {
                kind: 'FragmentReference',
                readerWithRefetchQueries,
                root: { __link: IsographEnvironment_1.ROOT_ID, __typename: entrypoint.concreteType },
                variables,
                networkRequest: networkRequest,
            },
            disposeNetworkRequest,
        ];
        return itemCleanupPair;
    };
    return getOrCreateItemInSuspenseCache(environment, cacheKey, factory);
}
function normalizeData(environment, normalizationAst, networkResponse, variables, root) {
    var _a, _b;
    var _c, _d, _e;
    const encounteredIds = new Map();
    (0, logging_1.logMessage)(environment, () => ({
        kind: 'AboutToNormalize',
        normalizationAst,
        networkResponse,
        variables,
    }));
    const recordsById = ((_a = (_c = environment.store)[_d = root.__typename]) !== null && _a !== void 0 ? _a : (_c[_d] = {}));
    const newStoreRecord = ((_b = recordsById[_e = root.__link]) !== null && _b !== void 0 ? _b : (recordsById[_e] = {}));
    normalizeDataIntoRecord(environment, normalizationAst, networkResponse, newStoreRecord, root, variables, encounteredIds);
    (0, logging_1.logMessage)(environment, () => ({
        kind: 'AfterNormalization',
        store: environment.store,
        encounteredIds,
    }));
    callSubscriptions(environment, encounteredIds);
    return encounteredIds;
}
function subscribeToAnyChange(environment, callback) {
    const subscription = {
        kind: 'AnyRecords',
        callback,
    };
    environment.subscriptions.add(subscription);
    return () => environment.subscriptions.delete(subscription);
}
function subscribeToAnyChangesToRecord(environment, recordLink, callback) {
    const subscription = {
        kind: 'AnyChangesToRecord',
        recordLink,
        callback,
    };
    environment.subscriptions.add(subscription);
    return () => environment.subscriptions.delete(subscription);
}
// TODO we should re-read and call callback if the value has changed
function subscribe(environment, encounteredDataAndRecords, fragmentReference, callback, readerAst) {
    const fragmentSubscription = {
        kind: 'FragmentSubscription',
        callback,
        encounteredDataAndRecords,
        fragmentReference,
        readerAst,
    };
    environment.subscriptions.add(fragmentSubscription);
    return () => environment.subscriptions.delete(fragmentSubscription);
}
function onNextChangeToRecord(environment, recordLink) {
    return new Promise((resolve) => {
        const unsubscribe = subscribeToAnyChangesToRecord(environment, recordLink, () => {
            unsubscribe();
            resolve();
        });
    });
}
// Calls to readButDoNotEvaluate can suspend (i.e. throw a promise).
// Maybe in the future, they will be able to throw errors.
//
// That's probably okay to ignore. We don't, however, want to prevent
// updating other subscriptions if one subscription had missing data.
function logAnyError(environment, context, f) {
    try {
        f();
    }
    catch (e) {
        (0, logging_1.logMessage)(environment, () => ({
            kind: 'ErrorEncounteredInWithErrorHandling',
            error: e,
            context,
        }));
    }
}
function callSubscriptions(environment, recordsEncounteredWhenNormalizing) {
    environment.subscriptions.forEach((subscription) => logAnyError(environment, { situation: 'calling subscriptions' }, () => {
        var _a;
        switch (subscription.kind) {
            case 'FragmentSubscription': {
                // TODO if there are multiple components subscribed to the same
                // fragment, we will call readButNotEvaluate multiple times. We
                // should fix that.
                if (hasOverlappingIds(recordsEncounteredWhenNormalizing, subscription.encounteredDataAndRecords.encounteredRecords)) {
                    const newEncounteredDataAndRecords = (0, read_1.readButDoNotEvaluate)(environment, subscription.fragmentReference, 
                    // Is this wrong?
                    // Reasons to think no:
                    // - we are only updating the read-out value, and the network
                    //   options only affect whether we throw.
                    // - the component will re-render, and re-throw on its own, anyway.
                    //
                    // Reasons to think not:
                    // - it seems more efficient to suspend here and not update state,
                    //   if we expect that the component will just throw anyway
                    // - consistency
                    // - it's also weird, this is called from makeNetworkRequest, where
                    //   we don't currently pass network request options
                    {
                        suspendIfInFlight: false,
                        throwOnNetworkError: false,
                    });
                    const mergedItem = (0, areEqualWithDeepComparison_1.mergeObjectsUsingReaderAst)(subscription.readerAst, subscription.encounteredDataAndRecords.item, newEncounteredDataAndRecords.item);
                    (0, logging_1.logMessage)(environment, () => ({
                        kind: 'DeepEqualityCheck',
                        fragmentReference: subscription.fragmentReference,
                        old: subscription.encounteredDataAndRecords.item,
                        new: newEncounteredDataAndRecords.item,
                        deeplyEqual: mergedItem === subscription.encounteredDataAndRecords.item,
                    }));
                    if (mergedItem !== subscription.encounteredDataAndRecords.item) {
                        logAnyError(environment, { situation: 'calling FragmentSubscription callback' }, () => {
                            subscription.callback(newEncounteredDataAndRecords);
                        });
                        subscription.encounteredDataAndRecords =
                            newEncounteredDataAndRecords;
                    }
                }
                return;
            }
            case 'AnyRecords': {
                logAnyError(environment, { situation: 'calling AnyRecords callback' }, () => subscription.callback());
                return;
            }
            case 'AnyChangesToRecord': {
                if ((_a = recordsEncounteredWhenNormalizing
                    .get(subscription.recordLink.__typename)) === null || _a === void 0 ? void 0 : _a.has(subscription.recordLink.__link)) {
                    logAnyError(environment, { situation: 'calling AnyChangesToRecord callback' }, () => subscription.callback());
                }
                return;
            }
            default: {
                // Ensure we have covered all variants
                const _ = subscription;
                _;
                throw new Error('Unexpected case');
            }
        }
    }));
}
function hasOverlappingIds(ids1, ids2) {
    for (const [typeName, set1] of ids1.entries()) {
        const set2 = ids2.get(typeName);
        if (set2 === undefined) {
            continue;
        }
        if (isNotDisjointFrom(set1, set2)) {
            return true;
        }
    }
    return false;
}
// TODO use a polyfill library
function isNotDisjointFrom(set1, set2) {
    for (const id of set1) {
        if (set2.has(id)) {
            return true;
        }
    }
    return false;
}
/**
 * Mutate targetParentRecord according to the normalizationAst and networkResponseParentRecord.
 */
function normalizeDataIntoRecord(environment, normalizationAst, networkResponseParentRecord, targetParentRecord, targetParentRecordLink, variables, mutableEncounteredIds) {
    let recordHasBeenUpdated = false;
    for (const normalizationNode of normalizationAst) {
        switch (normalizationNode.kind) {
            case 'Scalar': {
                const scalarFieldResultedInChange = normalizeScalarField(normalizationNode, networkResponseParentRecord, targetParentRecord, variables);
                recordHasBeenUpdated =
                    recordHasBeenUpdated || scalarFieldResultedInChange;
                break;
            }
            case 'Linked': {
                const linkedFieldResultedInChange = normalizeLinkedField(environment, normalizationNode, networkResponseParentRecord, targetParentRecord, targetParentRecordLink, variables, mutableEncounteredIds);
                recordHasBeenUpdated =
                    recordHasBeenUpdated || linkedFieldResultedInChange;
                break;
            }
            case 'InlineFragment': {
                const inlineFragmentResultedInChange = normalizeInlineFragment(environment, normalizationNode, networkResponseParentRecord, targetParentRecord, targetParentRecordLink, variables, mutableEncounteredIds);
                recordHasBeenUpdated =
                    recordHasBeenUpdated || inlineFragmentResultedInChange;
                break;
            }
            default: {
                // Ensure we have covered all variants
                let _ = normalizationNode;
                _;
                throw new Error('Unexpected normalization node kind');
            }
        }
    }
    if (recordHasBeenUpdated) {
        let encounteredRecordsIds = insertEmptySetIfMissing(mutableEncounteredIds, targetParentRecordLink.__typename);
        encounteredRecordsIds.add(targetParentRecordLink.__link);
    }
    return recordHasBeenUpdated;
}
function insertEmptySetIfMissing(map, key) {
    let result = map.get(key);
    if (result === undefined) {
        result = new Set();
        map.set(key, result);
    }
    return result;
}
function normalizeScalarField(astNode, networkResponseParentRecord, targetStoreRecord, variables) {
    const networkResponseKey = getNetworkResponseKey(astNode);
    const networkResponseData = networkResponseParentRecord[networkResponseKey];
    const parentRecordKey = getParentRecordKey(astNode, variables);
    if (networkResponseData == null ||
        isScalarOrEmptyArray(networkResponseData)) {
        const existingValue = targetStoreRecord[parentRecordKey];
        targetStoreRecord[parentRecordKey] = networkResponseData;
        return existingValue !== networkResponseData;
    }
    else {
        throw new Error('Unexpected object array when normalizing scalar');
    }
}
/**
 * Mutate targetParentRecord with a given linked field ast node.
 */
function normalizeLinkedField(environment, astNode, networkResponseParentRecord, targetParentRecord, targetParentRecordLink, variables, mutableEncounteredIds) {
    var _a, _b;
    const networkResponseKey = getNetworkResponseKey(astNode);
    const networkResponseData = networkResponseParentRecord[networkResponseKey];
    const parentRecordKey = getParentRecordKey(astNode, variables);
    const existingValue = targetParentRecord[parentRecordKey];
    if (networkResponseData == null) {
        targetParentRecord[parentRecordKey] = null;
        return existingValue !== null;
    }
    if (isScalarOrEmptyArray(networkResponseData) &&
        !isNullOrEmptyArray(networkResponseData)) {
        throw new Error('Unexpected scalar network response when normalizing a linked field');
    }
    if (Array.isArray(networkResponseData)) {
        // TODO check astNode.plural or the like
        const dataIds = [];
        for (let i = 0; i < networkResponseData.length; i++) {
            const networkResponseObject = networkResponseData[i];
            if (networkResponseObject == null) {
                dataIds.push(null);
                continue;
            }
            const newStoreRecordId = normalizeNetworkResponseObject(environment, astNode, networkResponseObject, targetParentRecordLink, variables, i, mutableEncounteredIds);
            const __typename = (_a = astNode.concreteType) !== null && _a !== void 0 ? _a : networkResponseObject[exports.TYPENAME_FIELD_NAME];
            if (__typename == null) {
                throw new Error('Unexpected missing __typename in network response when normalizing a linked field. ' +
                    'This is indicative of a bug in Isograph.');
            }
            dataIds.push({
                __link: newStoreRecordId,
                __typename,
            });
        }
        targetParentRecord[parentRecordKey] = dataIds;
        return !dataIdsAreTheSame(existingValue, dataIds);
    }
    else {
        const newStoreRecordId = normalizeNetworkResponseObject(environment, astNode, networkResponseData, targetParentRecordLink, variables, null, mutableEncounteredIds);
        let __typename = (_b = astNode.concreteType) !== null && _b !== void 0 ? _b : networkResponseData[exports.TYPENAME_FIELD_NAME];
        if (__typename == null) {
            throw new Error('Unexpected missing __typename in network response when normalizing a linked field. ' +
                'This is indicative of a bug in Isograph.');
        }
        targetParentRecord[parentRecordKey] = {
            __link: newStoreRecordId,
            __typename,
        };
        const link = (0, IsographEnvironment_1.getLink)(existingValue);
        return (link === null || link === void 0 ? void 0 : link.__link) !== newStoreRecordId || link.__typename !== __typename;
    }
}
/**
 * Mutate targetParentRecord with a given linked field ast node.
 */
function normalizeInlineFragment(environment, astNode, networkResponseParentRecord, targetParentRecord, targetParentRecordLink, variables, mutableEncounteredIds) {
    const typeToRefineTo = astNode.type;
    if (networkResponseParentRecord[exports.TYPENAME_FIELD_NAME] === typeToRefineTo) {
        const hasBeenModified = normalizeDataIntoRecord(environment, astNode.selections, networkResponseParentRecord, targetParentRecord, targetParentRecordLink, variables, mutableEncounteredIds);
        return hasBeenModified;
    }
    return false;
}
function dataIdsAreTheSame(existingValue, newDataIds) {
    var _a, _b;
    if (Array.isArray(existingValue)) {
        if (newDataIds.length !== existingValue.length) {
            return false;
        }
        for (let i = 0; i < newDataIds.length; i++) {
            const maybeLink = (0, IsographEnvironment_1.getLink)(existingValue[i]);
            if (((_a = newDataIds[i]) === null || _a === void 0 ? void 0 : _a.__link) !== (maybeLink === null || maybeLink === void 0 ? void 0 : maybeLink.__link) ||
                ((_b = newDataIds[i]) === null || _b === void 0 ? void 0 : _b.__typename) !== (maybeLink === null || maybeLink === void 0 ? void 0 : maybeLink.__typename)) {
                return false;
            }
        }
        return true;
    }
    else {
        return false;
    }
}
function normalizeNetworkResponseObject(environment, astNode, networkResponseData, targetParentRecordLink, variables, index, mutableEncounteredIds) {
    var _a, _b, _c;
    var _d;
    const newStoreRecordId = getDataIdOfNetworkResponse(targetParentRecordLink, networkResponseData, astNode, variables, index);
    const __typename = (_a = astNode.concreteType) !== null && _a !== void 0 ? _a : networkResponseData[exports.TYPENAME_FIELD_NAME];
    if (__typename == null) {
        throw new Error('Unexpected missing __typename in network response object. ' +
            'This is indicative of a bug in Isograph.');
    }
    const recordsById = ((_b = (_d = environment.store)[__typename]) !== null && _b !== void 0 ? _b : (_d[__typename] = {}));
    const newStoreRecord = ((_c = recordsById[newStoreRecordId]) !== null && _c !== void 0 ? _c : (recordsById[newStoreRecordId] = {}));
    normalizeDataIntoRecord(environment, astNode.selections, networkResponseData, newStoreRecord, { __link: newStoreRecordId, __typename: __typename }, variables, mutableEncounteredIds);
    return newStoreRecordId;
}
function isScalarOrEmptyArray(data) {
    // N.B. empty arrays count as empty arrays of scalar fields.
    if (Array.isArray(data)) {
        // This is maybe fixed in a new version of Typescript??
        return data.every((x) => isScalarOrEmptyArray(x));
    }
    const isScalarValue = data === null ||
        typeof data === 'string' ||
        typeof data === 'number' ||
        typeof data === 'boolean';
    return isScalarValue;
}
function isNullOrEmptyArray(data) {
    if (Array.isArray(data)) {
        if (data.length === 0) {
            return true;
        }
        return data.every((x) => isNullOrEmptyArray(x));
    }
    return data === null;
}
function getParentRecordKey(astNode, variables) {
    let parentRecordKey = astNode.fieldName;
    const fieldParameters = astNode.arguments;
    if (fieldParameters != null) {
        for (const fieldParameter of fieldParameters) {
            parentRecordKey += getStoreKeyChunkForArgument(fieldParameter, variables);
        }
    }
    return parentRecordKey;
}
function getStoreKeyChunkForArgumentValue(argumentValue, variables) {
    var _a;
    switch (argumentValue.kind) {
        case 'Object': {
            return Object.fromEntries(argumentValue.value.map(([argumentName, argumentValue]) => {
                return [
                    argumentName,
                    //  substitute variables
                    getStoreKeyChunkForArgumentValue(argumentValue, variables),
                ];
            }));
        }
        case 'Literal': {
            return argumentValue.value;
        }
        case 'Variable': {
            return (_a = variables[argumentValue.name]) !== null && _a !== void 0 ? _a : 'null';
        }
        case 'String': {
            return argumentValue.value;
        }
        case 'Enum': {
            return argumentValue.value;
        }
        default: {
            // TODO configure eslint to allow unused vars starting with _
            // Ensure we have covered all variants
            const _ = argumentValue;
            _;
            throw new Error('Unexpected case');
        }
    }
}
function getStoreKeyChunkForArgument(argument, variables) {
    const [argumentName, argumentValue] = argument;
    let chunk = getStoreKeyChunkForArgumentValue(argumentValue, variables);
    if (typeof chunk === 'object') {
        chunk = JSON.stringify(stableCopy(chunk));
    }
    return `${exports.FIRST_SPLIT_KEY}${argumentName}${exports.SECOND_SPLIT_KEY}${chunk}`;
}
function getNetworkResponseKey(astNode) {
    let networkResponseKey = astNode.fieldName;
    const fieldParameters = astNode.arguments;
    if (fieldParameters != null) {
        for (const [argumentName, argumentValue] of fieldParameters) {
            let argumentValueChunk = getArgumentValueChunk(argumentValue);
            networkResponseKey += `${exports.FIRST_SPLIT_KEY}${argumentName}${exports.SECOND_SPLIT_KEY}${argumentValueChunk}`;
        }
    }
    return networkResponseKey;
}
function getArgumentValueChunk(argumentValue) {
    switch (argumentValue.kind) {
        case 'Object': {
            return ('o_' +
                argumentValue.value
                    .map(([argumentName, argumentValue]) => {
                    return (argumentName +
                        exports.THIRD_SPLIT_KEY +
                        getArgumentValueChunk(argumentValue));
                })
                    .join('_') +
                '_c');
        }
        case 'Literal': {
            return 'l_' + argumentValue.value;
        }
        case 'Variable': {
            return 'v_' + argumentValue.name;
        }
        case 'String': {
            // replace all non-word characters (alphanumeric & underscore) with underscores
            return 's_' + argumentValue.value.replaceAll(/\W/g, '_');
        }
        case 'Enum': {
            return 'e_' + argumentValue.value;
        }
        default: {
            // Ensure we have covered all variants
            let _ = argumentValue;
            _;
            throw new Error('Unexpected case');
        }
    }
}
// an alias might be pullRequests____first___first____after___cursor
exports.FIRST_SPLIT_KEY = '____';
exports.SECOND_SPLIT_KEY = '___';
exports.THIRD_SPLIT_KEY = '__';
// Returns a key to look up an item in the store
function getDataIdOfNetworkResponse(parentRecordLink, dataToNormalize, astNode, variables, index) {
    // If we are dealing with nested Query, use __ROOT as id
    // TODO do not hard code this value here
    if (astNode.concreteType === 'Query') {
        return IsographEnvironment_1.ROOT_ID;
    }
    // Check whether the dataToNormalize has an id field. If so, that is the key.
    // If not, we construct an id from the parentRecordId and the field parameters.
    const dataId = dataToNormalize.id;
    if (dataId != null) {
        return dataId;
    }
    let storeKey = `${parentRecordLink.__typename}:${parentRecordLink.__link}.${astNode.fieldName}`;
    if (index != null) {
        storeKey += `.${index}`;
    }
    const fieldParameters = astNode.arguments;
    if (fieldParameters == null) {
        return storeKey;
    }
    for (const fieldParameter of fieldParameters) {
        storeKey += getStoreKeyChunkForArgument(fieldParameter, variables);
    }
    return storeKey;
}
