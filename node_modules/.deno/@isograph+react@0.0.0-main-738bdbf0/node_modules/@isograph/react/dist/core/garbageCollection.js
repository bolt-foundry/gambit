"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unretainQuery = unretainQuery;
exports.retainQuery = retainQuery;
exports.garbageCollectEnvironment = garbageCollectEnvironment;
const cache_1 = require("./cache");
const IsographEnvironment_1 = require("./IsographEnvironment");
function unretainQuery(environment, retainedQuery) {
    environment.retainedQueries.delete(retainedQuery);
    environment.gcBuffer.push(retainedQuery);
    if (environment.gcBuffer.length > environment.gcBufferSize) {
        environment.gcBuffer.shift();
        return true;
    }
    return false;
}
function retainQuery(environment, queryToRetain) {
    environment.retainedQueries.add(queryToRetain);
    // TODO can we remove this query from the buffer somehow?
    // We are relying on === equality, but we really should be comparing
    // id + variables
}
function garbageCollectEnvironment(environment) {
    const retainedIds = {};
    for (const query of environment.retainedQueries) {
        recordReachableIds(environment.store, query, retainedIds);
    }
    for (const query of environment.gcBuffer) {
        recordReachableIds(environment.store, query, retainedIds);
    }
    for (const typeName in environment.store) {
        const dataById = environment.store[typeName];
        if (dataById == null)
            continue;
        const retainedTypeIds = retainedIds[typeName];
        // delete all objects
        if (retainedTypeIds == undefined || retainedTypeIds.size == 0) {
            delete environment.store[typeName];
            continue;
        }
        for (const dataId in dataById) {
            if (!retainedTypeIds.has(dataId)) {
                delete dataById[dataId];
            }
        }
        if (Object.keys(dataById).length === 0) {
            delete environment.store[typeName];
        }
    }
}
function recordReachableIds(store, retainedQuery, mutableRetainedIds) {
    var _a, _b;
    var _c;
    const record = (_a = store[retainedQuery.root.__typename]) === null || _a === void 0 ? void 0 : _a[retainedQuery.root.__link];
    const retainedRecordsIds = ((_b = mutableRetainedIds[_c = retainedQuery.root.__typename]) !== null && _b !== void 0 ? _b : (mutableRetainedIds[_c] = new Set()));
    retainedRecordsIds.add(retainedQuery.root.__link);
    if (record) {
        recordReachableIdsFromRecord(store, record, mutableRetainedIds, retainedQuery.normalizationAst, retainedQuery.variables);
    }
}
function recordReachableIdsFromRecord(store, currentRecord, mutableRetainedIds, selections, variables) {
    var _a;
    for (const selection of selections) {
        switch (selection.kind) {
            case 'Linked':
                const linkKey = (0, cache_1.getParentRecordKey)(selection, variables !== null && variables !== void 0 ? variables : {});
                const linkedFieldOrFields = currentRecord[linkKey];
                const links = [];
                if (Array.isArray(linkedFieldOrFields)) {
                    for (const maybeLink of linkedFieldOrFields) {
                        const link = (0, IsographEnvironment_1.assertLink)(maybeLink);
                        if (link != null) {
                            links.push(link);
                        }
                    }
                }
                else {
                    const link = (0, IsographEnvironment_1.assertLink)(linkedFieldOrFields);
                    if (link != null) {
                        links.push(link);
                    }
                }
                let typeStore = selection.concreteType !== null
                    ? store[selection.concreteType]
                    : null;
                if (typeStore == null && selection.concreteType !== null) {
                    continue;
                }
                for (const nextRecordLink of links) {
                    let __typename = nextRecordLink.__typename;
                    const resolvedTypeStore = typeStore !== null && typeStore !== void 0 ? typeStore : store[__typename];
                    if (resolvedTypeStore == null) {
                        continue;
                    }
                    const nextRecord = resolvedTypeStore[nextRecordLink.__link];
                    if (nextRecord != null) {
                        const retainedRecordsIds = ((_a = mutableRetainedIds[__typename]) !== null && _a !== void 0 ? _a : (mutableRetainedIds[__typename] = new Set()));
                        retainedRecordsIds.add(nextRecordLink.__link);
                        recordReachableIdsFromRecord(store, nextRecord, mutableRetainedIds, selection.selections, variables);
                    }
                }
                continue;
            case 'Scalar':
                continue;
        }
    }
}
