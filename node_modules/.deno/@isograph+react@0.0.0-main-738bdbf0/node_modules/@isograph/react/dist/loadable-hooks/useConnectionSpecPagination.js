"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useConnectionSpecPagination = useConnectionSpecPagination;
const react_disposable_state_1 = require("@isograph/react-disposable-state");
const reference_counted_pointer_1 = require("@isograph/reference-counted-pointer");
const react_1 = require("react");
const cache_1 = require("../core/cache");
const PromiseWrapper_1 = require("../core/PromiseWrapper");
const read_1 = require("../core/read");
const startUpdate_1 = require("../core/startUpdate");
const IsographEnvironmentProvider_1 = require("../react/IsographEnvironmentProvider");
const useReadAndSubscribe_1 = require("../react/useReadAndSubscribe");
const useResult_1 = require("../react/useResult");
function flatten(arr) {
    let outArray = [];
    for (const subarr of arr) {
        for (const item of subarr) {
            outArray.push(item);
        }
    }
    return outArray;
}
function useConnectionSpecPagination(loadableField, initialState) {
    var _a, _b;
    const networkRequestOptions = {
        suspendIfInFlight: true,
        throwOnNetworkError: true,
    };
    const { state, setState } = (0, react_disposable_state_1.useUpdatableDisposableState)();
    const environment = (0, IsographEnvironmentProvider_1.useIsographEnvironment)();
    // TODO move this out of useSkipLimitPagination, and pass environment and networkRequestOptions
    // as parameters (or recreate networkRequestOptions)
    function readCompletedFragmentReferences(completedReferences) {
        var _a, _b;
        const results = completedReferences.map((fragmentReference, i) => {
            var _a;
            const readerWithRefetchQueries = (0, PromiseWrapper_1.readPromise)(fragmentReference.readerWithRefetchQueries);
            // invariant: readOutDataAndRecords.length === completedReferences.length
            const data = (_a = readOutDataAndRecords[i]) === null || _a === void 0 ? void 0 : _a.item;
            if (data == null) {
                throw new Error('Parameter data is unexpectedly null. This is indicative of a bug in Isograph.');
            }
            const firstParameter = Object.assign({ data, parameters: fragmentReference.variables }, (readerWithRefetchQueries.readerArtifact.hasUpdatable
                ? {
                    startUpdate: (0, startUpdate_1.getOrCreateCachedStartUpdate)(environment, fragmentReference, readerWithRefetchQueries.readerArtifact.fieldName, networkRequestOptions),
                }
                : undefined));
            if (readerWithRefetchQueries.readerArtifact.kind !== 'EagerReaderArtifact') {
                throw new Error(`@loadable field of kind "${readerWithRefetchQueries.readerArtifact.kind}" is not supported by useSkipLimitPagination`);
            }
            return readerWithRefetchQueries.readerArtifact.resolver(firstParameter);
        });
        const items = flatten(results.map((result) => { var _a; return (_a = result.edges) !== null && _a !== void 0 ? _a : []; }));
        return {
            edges: items,
            pageInfo: (_b = (_a = results[results.length - 1]) === null || _a === void 0 ? void 0 : _a.pageInfo) !== null && _b !== void 0 ? _b : {
                endCursor: null,
                hasNextPage: true,
            },
        };
    }
    function subscribeCompletedFragmentReferences(completedReferences) {
        return completedReferences.map((fragmentReference, i) => {
            (0, useResult_1.maybeUnwrapNetworkRequest)(fragmentReference.networkRequest, networkRequestOptions);
            const readerWithRefetchQueries = (0, PromiseWrapper_1.readPromise)(fragmentReference.readerWithRefetchQueries);
            const records = readOutDataAndRecords[i];
            if (records == null) {
                throw new Error('subscribeCompletedFragmentReferences records is unexpectedly null');
            }
            return {
                fragmentReference,
                readerAst: readerWithRefetchQueries.readerArtifact.readerAst,
                records,
                callback(_data) {
                    rerender({});
                },
            };
        });
    }
    const getFetchMore = (after) => (count, fetchOptions) => {
        const loadedField = loadableField({
            after: after,
            first: count,
        }, fetchOptions !== null && fetchOptions !== void 0 ? fetchOptions : {})[1]();
        const newPointer = (0, reference_counted_pointer_1.createReferenceCountedPointer)(loadedField);
        const clonedPointers = loadedReferences.map(([refCountedPointer]) => {
            const clonedRefCountedPointer = refCountedPointer.cloneIfNotDisposed();
            if (clonedRefCountedPointer == null) {
                throw new Error('This reference counted pointer has already been disposed. \
            This is indicative of a bug in useSkipLimitPagination.');
            }
            return clonedRefCountedPointer;
        });
        clonedPointers.push(newPointer);
        const totalItemCleanupPair = [
            clonedPointers,
            () => {
                clonedPointers.forEach(([, dispose]) => {
                    dispose();
                });
            },
        ];
        setState(totalItemCleanupPair);
    };
    const [, rerender] = (0, react_1.useState)({});
    const loadedReferences = state === react_disposable_state_1.UNASSIGNED_STATE ? [] : state;
    const mostRecentItem = loadedReferences[loadedReferences.length - 1];
    const mostRecentFragmentReference = mostRecentItem === null || mostRecentItem === void 0 ? void 0 : mostRecentItem[0].getItemIfNotDisposed();
    if (mostRecentItem && mostRecentFragmentReference === null) {
        throw new Error('FragmentReference is unexpectedly disposed. \
      This is indicative of a bug in Isograph.');
    }
    const networkRequestStatus = mostRecentFragmentReference &&
        (0, PromiseWrapper_1.getPromiseState)(mostRecentFragmentReference.networkRequest);
    const slicedFragmentReferences = (networkRequestStatus === null || networkRequestStatus === void 0 ? void 0 : networkRequestStatus.kind) === 'Ok'
        ? loadedReferences
        : loadedReferences.slice(0, loadedReferences.length - 1);
    const completedFragmentReferences = slicedFragmentReferences.map(([pointer]) => {
        const fragmentReference = pointer.getItemIfNotDisposed();
        if (fragmentReference == null) {
            throw new Error('FragmentReference is unexpectedly disposed. \
            This is indicative of a bug in Isograph.');
        }
        return fragmentReference;
    });
    const readOutDataAndRecords = completedFragmentReferences.map((fragmentReference) => (0, read_1.readButDoNotEvaluate)(environment, fragmentReference, networkRequestOptions));
    (0, useReadAndSubscribe_1.useSubscribeToMultiple)(subscribeCompletedFragmentReferences(completedFragmentReferences));
    if (!networkRequestStatus) {
        return {
            kind: 'Complete',
            fetchMore: getFetchMore((_a = initialState === null || initialState === void 0 ? void 0 : initialState.endCursor) !== null && _a !== void 0 ? _a : null),
            results: [],
            hasNextPage: (_b = initialState === null || initialState === void 0 ? void 0 : initialState.hasNextPage) !== null && _b !== void 0 ? _b : true,
        };
    }
    switch (networkRequestStatus.kind) {
        case 'Pending': {
            const unsubscribe = (0, cache_1.subscribeToAnyChange)(environment, () => {
                unsubscribe();
                rerender({});
            });
            const results = readCompletedFragmentReferences(completedFragmentReferences);
            return {
                results: results.edges,
                kind: 'Pending',
                pendingFragment: mostRecentFragmentReference,
            };
        }
        case 'Err': {
            throw networkRequestStatus.error;
        }
        case 'Ok': {
            const results = readCompletedFragmentReferences(completedFragmentReferences);
            return {
                results: results.edges,
                hasNextPage: results.pageInfo.hasNextPage,
                kind: 'Complete',
                fetchMore: getFetchMore(results.pageInfo.endCursor),
            };
        }
    }
}
