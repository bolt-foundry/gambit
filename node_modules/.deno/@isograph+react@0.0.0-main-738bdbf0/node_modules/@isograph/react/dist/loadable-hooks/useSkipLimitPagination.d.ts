import { FetchOptions } from '../core/check';
import { FragmentReference, type UnknownTReadFromStore } from '../core/FragmentReference';
import { LoadableField } from '../core/reader';
export type UseSkipLimitReturnValue<TReadFromStore extends UnknownTReadFromStore, TItem> = {
    readonly kind: 'Complete';
    readonly fetchMore: (count: number, fetchOptions?: FetchOptions<ReadonlyArray<TItem>>) => void;
    readonly results: ReadonlyArray<TItem>;
} | {
    readonly kind: 'Pending';
    readonly results: ReadonlyArray<TItem>;
    readonly pendingFragment: FragmentReference<TReadFromStore, ReadonlyArray<TItem>>;
};
export type UseSkipLimitPaginationArgs = {
    skip: number;
    limit: number;
};
export declare function useSkipLimitPagination<TItem, TReadFromStore extends UnknownTReadFromStore>(loadableField: LoadableField<TReadFromStore, ReadonlyArray<TItem>, UseSkipLimitPaginationArgs>, initialState?: {
    skip?: number | void | null;
}): UseSkipLimitReturnValue<TReadFromStore, TItem>;
//# sourceMappingURL=useSkipLimitPagination.d.ts.map